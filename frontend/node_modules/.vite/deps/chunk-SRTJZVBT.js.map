{
  "version": 3,
  "sources": ["../../micromark-util-symbol/constants.js", "../../micromark-util-chunked/dev/index.js", "../../micromark-util-combine-extensions/index.js", "../../dequal/dist/index.mjs", "../../kleur/index.mjs", "../../diff/lib/index.es6.js", "../../uvu/diff/index.mjs", "../../uvu/assert/index.mjs", "../../micromark-util-symbol/codes.js", "../../micromark-util-character/dev/lib/unicode-punctuation-regex.js", "../../micromark-util-character/dev/index.js", "../../micromark-factory-space/dev/index.js", "../../micromark-util-symbol/types.js", "../../micromark-util-classify-character/dev/index.js", "../../micromark-util-resolve-all/index.js", "../../micromark-core-commonmark/dev/lib/blank-line.js", "../../micromark-util-symbol/values.js", "../../micromark-util-normalize-identifier/dev/index.js", "../../micromark-core-commonmark/dev/lib/attention.js", "../../micromark-core-commonmark/dev/lib/autolink.js", "../../micromark-core-commonmark/dev/lib/block-quote.js", "../../micromark-core-commonmark/dev/lib/character-escape.js", "../../decode-named-character-reference/index.dom.js", "../../micromark-core-commonmark/dev/lib/character-reference.js", "../../micromark-core-commonmark/dev/lib/code-fenced.js", "../../micromark-core-commonmark/dev/lib/code-indented.js", "../../micromark-core-commonmark/dev/lib/code-text.js", "../../micromark-util-subtokenize/dev/index.js", "../../micromark-core-commonmark/dev/lib/content.js", "../../micromark-factory-destination/dev/index.js", "../../micromark-factory-label/dev/index.js", "../../micromark-factory-title/dev/index.js", "../../micromark-factory-whitespace/dev/index.js", "../../micromark-core-commonmark/dev/lib/definition.js", "../../micromark-core-commonmark/dev/lib/hard-break-escape.js", "../../micromark-core-commonmark/dev/lib/heading-atx.js", "../../micromark-util-html-tag-name/index.js", "../../micromark-core-commonmark/dev/lib/html-flow.js", "../../micromark-core-commonmark/dev/lib/html-text.js", "../../micromark-core-commonmark/dev/lib/label-end.js", "../../micromark-core-commonmark/dev/lib/label-start-image.js", "../../micromark-core-commonmark/dev/lib/label-start-link.js", "../../micromark-core-commonmark/dev/lib/line-ending.js", "../../micromark-core-commonmark/dev/lib/thematic-break.js", "../../micromark-core-commonmark/dev/lib/list.js", "../../micromark-core-commonmark/dev/lib/setext-underline.js", "../../micromark-util-decode-numeric-character-reference/dev/index.js", "../../micromark-util-decode-string/dev/index.js"],
  "sourcesContent": ["/**\r\n * This module is compiled away!\r\n *\r\n * Parsing markdown comes with a couple of constants, such as minimum or maximum\r\n * sizes of certain sequences.\r\n * Additionally, there are a couple symbols used inside micromark.\r\n * These are all defined here, but compiled away by scripts.\r\n */\r\nexport const constants = {\r\n  attentionSideBefore: 1, // Symbol to mark an attention sequence as before content: `*a`\r\n  attentionSideAfter: 2, // Symbol to mark an attention sequence as after content: `a*`\r\n  atxHeadingOpeningFenceSizeMax: 6, // 6 number signs is fine, 7 isn’t.\r\n  autolinkDomainSizeMax: 63, // 63 characters is fine, 64 is too many.\r\n  autolinkSchemeSizeMax: 32, // 32 characters is fine, 33 is too many.\r\n  cdataOpeningString: 'CDATA[', // And preceded by `<![`.\r\n  characterGroupWhitespace: 1, // Symbol used to indicate a character is whitespace\r\n  characterGroupPunctuation: 2, // Symbol used to indicate a character is punctuation\r\n  characterReferenceDecimalSizeMax: 7, // `&#9999999;`.\r\n  characterReferenceHexadecimalSizeMax: 6, // `&#xff9999;`.\r\n  characterReferenceNamedSizeMax: 31, // `&CounterClockwiseContourIntegral;`.\r\n  codeFencedSequenceSizeMin: 3, // At least 3 ticks or tildes are needed.\r\n  contentTypeDocument: 'document',\r\n  contentTypeFlow: 'flow',\r\n  contentTypeContent: 'content',\r\n  contentTypeString: 'string',\r\n  contentTypeText: 'text',\r\n  hardBreakPrefixSizeMin: 2, // At least 2 trailing spaces are needed.\r\n  htmlRaw: 1, // Symbol for `<script>`\r\n  htmlComment: 2, // Symbol for `<!---->`\r\n  htmlInstruction: 3, // Symbol for `<?php?>`\r\n  htmlDeclaration: 4, // Symbol for `<!doctype>`\r\n  htmlCdata: 5, // Symbol for `<![CDATA[]]>`\r\n  htmlBasic: 6, // Symbol for `<div`\r\n  htmlComplete: 7, // Symbol for `<x>`\r\n  htmlRawSizeMax: 8, // Length of `textarea`.\r\n  linkResourceDestinationBalanceMax: 32, // See: <https://spec.commonmark.org/0.30/#link-destination>, <https://github.com/remarkjs/react-markdown/issues/658#issuecomment-984345577>\r\n  linkReferenceSizeMax: 999, // See: <https://spec.commonmark.org/0.30/#link-label>\r\n  listItemValueSizeMax: 10, // See: <https://spec.commonmark.org/0.30/#ordered-list-marker>\r\n  numericBaseDecimal: 10,\r\n  numericBaseHexadecimal: 0x10,\r\n  tabSize: 4, // Tabs have a hard-coded size of 4, per CommonMark.\r\n  thematicBreakMarkerCountMin: 3, // At least 3 asterisks, dashes, or underscores are needed.\r\n  v8MaxSafeChunkSize: 10000 // V8 (and potentially others) have problems injecting giant arrays into other arrays, hence we operate in chunks.\r\n}\r\n", "import {constants} from 'micromark-util-symbol/constants.js'\r\n\r\n/**\r\n * Like `Array#splice`, but smarter for giant arrays.\r\n *\r\n * `Array#splice` takes all items to be inserted as individual argument which\r\n * causes a stack overflow in V8 when trying to insert 100k items for instance.\r\n *\r\n * Otherwise, this does not return the removed items, and takes `items` as an\r\n * array instead of rest parameters.\r\n *\r\n * @template {unknown} T\r\n * @param {T[]} list\r\n * @param {number} start\r\n * @param {number} remove\r\n * @param {T[]} items\r\n * @returns {void}\r\n */\r\nexport function splice(list, start, remove, items) {\r\n  const end = list.length\r\n  let chunkStart = 0\r\n  /** @type {unknown[]} */\r\n  let parameters\r\n\r\n  // Make start between zero and `end` (included).\r\n  if (start < 0) {\r\n    start = -start > end ? 0 : end + start\r\n  } else {\r\n    start = start > end ? end : start\r\n  }\r\n\r\n  remove = remove > 0 ? remove : 0\r\n\r\n  // No need to chunk the items if there’s only a couple (10k) items.\r\n  if (items.length < constants.v8MaxSafeChunkSize) {\r\n    parameters = Array.from(items)\r\n    parameters.unshift(start, remove)\r\n    // @ts-expect-error Hush, it’s fine.\r\n    ;[].splice.apply(list, parameters)\r\n  } else {\r\n    // Delete `remove` items starting from `start`\r\n    if (remove) [].splice.apply(list, [start, remove])\r\n\r\n    // Insert the items in chunks to not cause stack overflows.\r\n    while (chunkStart < items.length) {\r\n      parameters = items.slice(\r\n        chunkStart,\r\n        chunkStart + constants.v8MaxSafeChunkSize\r\n      )\r\n      parameters.unshift(start, 0)\r\n      // @ts-expect-error Hush, it’s fine.\r\n      ;[].splice.apply(list, parameters)\r\n\r\n      chunkStart += constants.v8MaxSafeChunkSize\r\n      start += constants.v8MaxSafeChunkSize\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Append `items` (an array) at the end of `list` (another array).\r\n * When `list` was empty, returns `items` instead.\r\n *\r\n * This prevents a potentially expensive operation when `list` is empty,\r\n * and adds items in batches to prevent V8 from hanging.\r\n *\r\n * @template {unknown} T\r\n * @param {T[]} list\r\n * @param {T[]} items\r\n * @returns {T[]}\r\n */\r\nexport function push(list, items) {\r\n  if (list.length > 0) {\r\n    splice(list, list.length, 0, items)\r\n    return list\r\n  }\r\n\r\n  return items\r\n}\r\n", "/**\r\n * @typedef {import('micromark-util-types').NormalizedExtension} NormalizedExtension\r\n * @typedef {import('micromark-util-types').Extension} Extension\r\n * @typedef {import('micromark-util-types').Construct} Construct\r\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\r\n */\r\n\r\nimport {splice} from 'micromark-util-chunked'\r\n\r\nconst hasOwnProperty = {}.hasOwnProperty\r\n\r\n/**\r\n * Combine several syntax extensions into one.\r\n *\r\n * @param {Extension[]} extensions List of syntax extensions.\r\n * @returns {NormalizedExtension} A single combined extension.\r\n */\r\nexport function combineExtensions(extensions) {\r\n  /** @type {NormalizedExtension} */\r\n  const all = {}\r\n  let index = -1\r\n\r\n  while (++index < extensions.length) {\r\n    syntaxExtension(all, extensions[index])\r\n  }\r\n\r\n  return all\r\n}\r\n\r\n/**\r\n * Merge `extension` into `all`.\r\n *\r\n * @param {NormalizedExtension} all Extension to merge into.\r\n * @param {Extension} extension Extension to merge.\r\n * @returns {void}\r\n */\r\nfunction syntaxExtension(all, extension) {\r\n  /** @type {string} */\r\n  let hook\r\n\r\n  for (hook in extension) {\r\n    const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined\r\n    const left = maybe || (all[hook] = {})\r\n    const right = extension[hook]\r\n    /** @type {string} */\r\n    let code\r\n\r\n    for (code in right) {\r\n      if (!hasOwnProperty.call(left, code)) left[code] = []\r\n      const value = right[code]\r\n      constructs(\r\n        // @ts-expect-error Looks like a list.\r\n        left[code],\r\n        Array.isArray(value) ? value : value ? [value] : []\r\n      )\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Merge `list` into `existing` (both lists of constructs).\r\n * Mutates `existing`.\r\n *\r\n * @param {unknown[]} existing\r\n * @param {unknown[]} list\r\n * @returns {void}\r\n */\r\nfunction constructs(existing, list) {\r\n  let index = -1\r\n  /** @type {unknown[]} */\r\n  const before = []\r\n\r\n  while (++index < list.length) {\r\n    // @ts-expect-error Looks like an object.\r\n    ;(list[index].add === 'after' ? existing : before).push(list[index])\r\n  }\r\n\r\n  splice(existing, 0, 0, before)\r\n}\r\n\r\n/**\r\n * Combine several HTML extensions into one.\r\n *\r\n * @param {HtmlExtension[]} htmlExtensions List of HTML extensions.\r\n * @returns {HtmlExtension} A single combined extension.\r\n */\r\nexport function combineHtmlExtensions(htmlExtensions) {\r\n  /** @type {HtmlExtension} */\r\n  const handlers = {}\r\n  let index = -1\r\n\r\n  while (++index < htmlExtensions.length) {\r\n    htmlExtension(handlers, htmlExtensions[index])\r\n  }\r\n\r\n  return handlers\r\n}\r\n\r\n/**\r\n * Merge `extension` into `all`.\r\n *\r\n * @param {HtmlExtension} all Extension to merge into.\r\n * @param {HtmlExtension} extension Extension to merge.\r\n * @returns {void}\r\n */\r\nfunction htmlExtension(all, extension) {\r\n  /** @type {string} */\r\n  let hook\r\n\r\n  for (hook in extension) {\r\n    const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined\r\n    const left = maybe || (all[hook] = {})\r\n    const right = extension[hook]\r\n    /** @type {string} */\r\n    let type\r\n\r\n    if (right) {\r\n      for (type in right) {\r\n        left[type] = right[type]\r\n      }\r\n    }\r\n  }\r\n}\r\n", "var has = Object.prototype.hasOwnProperty;\r\n\r\nfunction find(iter, tar, key) {\r\n\tfor (key of iter.keys()) {\r\n\t\tif (dequal(key, tar)) return key;\r\n\t}\r\n}\r\n\r\nexport function dequal(foo, bar) {\r\n\tvar ctor, len, tmp;\r\n\tif (foo === bar) return true;\r\n\r\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\r\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\r\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\r\n\r\n\t\tif (ctor === Array) {\r\n\t\t\tif ((len=foo.length) === bar.length) {\r\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\r\n\t\t\t}\r\n\t\t\treturn len === -1;\r\n\t\t}\r\n\r\n\t\tif (ctor === Set) {\r\n\t\t\tif (foo.size !== bar.size) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tfor (len of foo) {\r\n\t\t\t\ttmp = len;\r\n\t\t\t\tif (tmp && typeof tmp === 'object') {\r\n\t\t\t\t\ttmp = find(bar, tmp);\r\n\t\t\t\t\tif (!tmp) return false;\r\n\t\t\t\t}\r\n\t\t\t\tif (!bar.has(tmp)) return false;\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif (ctor === Map) {\r\n\t\t\tif (foo.size !== bar.size) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tfor (len of foo) {\r\n\t\t\t\ttmp = len[0];\r\n\t\t\t\tif (tmp && typeof tmp === 'object') {\r\n\t\t\t\t\ttmp = find(bar, tmp);\r\n\t\t\t\t\tif (!tmp) return false;\r\n\t\t\t\t}\r\n\t\t\t\tif (!dequal(len[1], bar.get(tmp))) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif (ctor === ArrayBuffer) {\r\n\t\t\tfoo = new Uint8Array(foo);\r\n\t\t\tbar = new Uint8Array(bar);\r\n\t\t} else if (ctor === DataView) {\r\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\r\n\t\t\t\twhile (len-- && foo.getInt8(len) === bar.getInt8(len));\r\n\t\t\t}\r\n\t\t\treturn len === -1;\r\n\t\t}\r\n\r\n\t\tif (ArrayBuffer.isView(foo)) {\r\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\r\n\t\t\t\twhile (len-- && foo[len] === bar[len]);\r\n\t\t\t}\r\n\t\t\treturn len === -1;\r\n\t\t}\r\n\r\n\t\tif (!ctor || typeof foo === 'object') {\r\n\t\t\tlen = 0;\r\n\t\t\tfor (ctor in foo) {\r\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\r\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\r\n\t\t\t}\r\n\t\t\treturn Object.keys(bar).length === len;\r\n\t\t}\r\n\t}\r\n\r\n\treturn foo !== foo && bar !== bar;\r\n}\r\n", "'use strict';\r\n\r\nlet FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM, isTTY=true;\r\nif (typeof process !== 'undefined') {\r\n\t({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env || {});\r\n\tisTTY = process.stdout && process.stdout.isTTY;\r\n}\r\n\r\nconst $ = {\r\n\tenabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== 'dumb' && (\r\n\t\tFORCE_COLOR != null && FORCE_COLOR !== '0' || isTTY\r\n\t),\r\n\r\n\t// modifiers\r\n\treset: init(0, 0),\r\n\tbold: init(1, 22),\r\n\tdim: init(2, 22),\r\n\titalic: init(3, 23),\r\n\tunderline: init(4, 24),\r\n\tinverse: init(7, 27),\r\n\thidden: init(8, 28),\r\n\tstrikethrough: init(9, 29),\r\n\r\n\t// colors\r\n\tblack: init(30, 39),\r\n\tred: init(31, 39),\r\n\tgreen: init(32, 39),\r\n\tyellow: init(33, 39),\r\n\tblue: init(34, 39),\r\n\tmagenta: init(35, 39),\r\n\tcyan: init(36, 39),\r\n\twhite: init(37, 39),\r\n\tgray: init(90, 39),\r\n\tgrey: init(90, 39),\r\n\r\n\t// background colors\r\n\tbgBlack: init(40, 49),\r\n\tbgRed: init(41, 49),\r\n\tbgGreen: init(42, 49),\r\n\tbgYellow: init(43, 49),\r\n\tbgBlue: init(44, 49),\r\n\tbgMagenta: init(45, 49),\r\n\tbgCyan: init(46, 49),\r\n\tbgWhite: init(47, 49)\r\n};\r\n\r\nfunction run(arr, str) {\r\n\tlet i=0, tmp, beg='', end='';\r\n\tfor (; i < arr.length; i++) {\r\n\t\ttmp = arr[i];\r\n\t\tbeg += tmp.open;\r\n\t\tend += tmp.close;\r\n\t\tif (!!~str.indexOf(tmp.close)) {\r\n\t\t\tstr = str.replace(tmp.rgx, tmp.close + tmp.open);\r\n\t\t}\r\n\t}\r\n\treturn beg + str + end;\r\n}\r\n\r\nfunction chain(has, keys) {\r\n\tlet ctx = { has, keys };\r\n\r\n\tctx.reset = $.reset.bind(ctx);\r\n\tctx.bold = $.bold.bind(ctx);\r\n\tctx.dim = $.dim.bind(ctx);\r\n\tctx.italic = $.italic.bind(ctx);\r\n\tctx.underline = $.underline.bind(ctx);\r\n\tctx.inverse = $.inverse.bind(ctx);\r\n\tctx.hidden = $.hidden.bind(ctx);\r\n\tctx.strikethrough = $.strikethrough.bind(ctx);\r\n\r\n\tctx.black = $.black.bind(ctx);\r\n\tctx.red = $.red.bind(ctx);\r\n\tctx.green = $.green.bind(ctx);\r\n\tctx.yellow = $.yellow.bind(ctx);\r\n\tctx.blue = $.blue.bind(ctx);\r\n\tctx.magenta = $.magenta.bind(ctx);\r\n\tctx.cyan = $.cyan.bind(ctx);\r\n\tctx.white = $.white.bind(ctx);\r\n\tctx.gray = $.gray.bind(ctx);\r\n\tctx.grey = $.grey.bind(ctx);\r\n\r\n\tctx.bgBlack = $.bgBlack.bind(ctx);\r\n\tctx.bgRed = $.bgRed.bind(ctx);\r\n\tctx.bgGreen = $.bgGreen.bind(ctx);\r\n\tctx.bgYellow = $.bgYellow.bind(ctx);\r\n\tctx.bgBlue = $.bgBlue.bind(ctx);\r\n\tctx.bgMagenta = $.bgMagenta.bind(ctx);\r\n\tctx.bgCyan = $.bgCyan.bind(ctx);\r\n\tctx.bgWhite = $.bgWhite.bind(ctx);\r\n\r\n\treturn ctx;\r\n}\r\n\r\nfunction init(open, close) {\r\n\tlet blk = {\r\n\t\topen: `\\x1b[${open}m`,\r\n\t\tclose: `\\x1b[${close}m`,\r\n\t\trgx: new RegExp(`\\\\x1b\\\\[${close}m`, 'g')\r\n\t};\r\n\treturn function (txt) {\r\n\t\tif (this !== void 0 && this.has !== void 0) {\r\n\t\t\t!!~this.has.indexOf(open) || (this.has.push(open),this.keys.push(blk));\r\n\t\t\treturn txt === void 0 ? this : $.enabled ? run(this.keys, txt+'') : txt+'';\r\n\t\t}\r\n\t\treturn txt === void 0 ? chain([open], [blk]) : $.enabled ? run([blk], txt+'') : txt+'';\r\n\t};\r\n}\r\n\r\nexport default $;\r\n", "function Diff() {}\r\nDiff.prototype = {\r\n  diff: function diff(oldString, newString) {\r\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\r\n    var callback = options.callback;\r\n\r\n    if (typeof options === 'function') {\r\n      callback = options;\r\n      options = {};\r\n    }\r\n\r\n    this.options = options;\r\n    var self = this;\r\n\r\n    function done(value) {\r\n      if (callback) {\r\n        setTimeout(function () {\r\n          callback(undefined, value);\r\n        }, 0);\r\n        return true;\r\n      } else {\r\n        return value;\r\n      }\r\n    } // Allow subclasses to massage the input prior to running\r\n\r\n\r\n    oldString = this.castInput(oldString);\r\n    newString = this.castInput(newString);\r\n    oldString = this.removeEmpty(this.tokenize(oldString));\r\n    newString = this.removeEmpty(this.tokenize(newString));\r\n    var newLen = newString.length,\r\n        oldLen = oldString.length;\r\n    var editLength = 1;\r\n    var maxEditLength = newLen + oldLen;\r\n\r\n    if (options.maxEditLength) {\r\n      maxEditLength = Math.min(maxEditLength, options.maxEditLength);\r\n    }\r\n\r\n    var bestPath = [{\r\n      newPos: -1,\r\n      components: []\r\n    }]; // Seed editLength = 0, i.e. the content starts with the same values\r\n\r\n    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\r\n\r\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\r\n      // Identity per the equality and tokenizer\r\n      return done([{\r\n        value: this.join(newString),\r\n        count: newString.length\r\n      }]);\r\n    } // Main worker method. checks all permutations of a given edit length for acceptance.\r\n\r\n\r\n    function execEditLength() {\r\n      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\r\n        var basePath = void 0;\r\n\r\n        var addPath = bestPath[diagonalPath - 1],\r\n            removePath = bestPath[diagonalPath + 1],\r\n            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\r\n\r\n        if (addPath) {\r\n          // No one else is going to attempt to use this value, clear it\r\n          bestPath[diagonalPath - 1] = undefined;\r\n        }\r\n\r\n        var canAdd = addPath && addPath.newPos + 1 < newLen,\r\n            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;\r\n\r\n        if (!canAdd && !canRemove) {\r\n          // If this path is a terminal then prune\r\n          bestPath[diagonalPath] = undefined;\r\n          continue;\r\n        } // Select the diagonal that we want to branch from. We select the prior\r\n        // path whose position in the new string is the farthest from the origin\r\n        // and does not pass the bounds of the diff graph\r\n\r\n\r\n        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\r\n          basePath = clonePath(removePath);\r\n          self.pushComponent(basePath.components, undefined, true);\r\n        } else {\r\n          basePath = addPath; // No need to clone, we've pulled it from the list\r\n\r\n          basePath.newPos++;\r\n          self.pushComponent(basePath.components, true, undefined);\r\n        }\r\n\r\n        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done\r\n\r\n        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {\r\n          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\r\n        } else {\r\n          // Otherwise track this path as a potential candidate and continue.\r\n          bestPath[diagonalPath] = basePath;\r\n        }\r\n      }\r\n\r\n      editLength++;\r\n    } // Performs the length of edit iteration. Is a bit fugly as this has to support the\r\n    // sync and async mode which is never fun. Loops over execEditLength until a value\r\n    // is produced, or until the edit length exceeds options.maxEditLength (if given),\r\n    // in which case it will return undefined.\r\n\r\n\r\n    if (callback) {\r\n      (function exec() {\r\n        setTimeout(function () {\r\n          if (editLength > maxEditLength) {\r\n            return callback();\r\n          }\r\n\r\n          if (!execEditLength()) {\r\n            exec();\r\n          }\r\n        }, 0);\r\n      })();\r\n    } else {\r\n      while (editLength <= maxEditLength) {\r\n        var ret = execEditLength();\r\n\r\n        if (ret) {\r\n          return ret;\r\n        }\r\n      }\r\n    }\r\n  },\r\n  pushComponent: function pushComponent(components, added, removed) {\r\n    var last = components[components.length - 1];\r\n\r\n    if (last && last.added === added && last.removed === removed) {\r\n      // We need to clone here as the component clone operation is just\r\n      // as shallow array clone\r\n      components[components.length - 1] = {\r\n        count: last.count + 1,\r\n        added: added,\r\n        removed: removed\r\n      };\r\n    } else {\r\n      components.push({\r\n        count: 1,\r\n        added: added,\r\n        removed: removed\r\n      });\r\n    }\r\n  },\r\n  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\r\n    var newLen = newString.length,\r\n        oldLen = oldString.length,\r\n        newPos = basePath.newPos,\r\n        oldPos = newPos - diagonalPath,\r\n        commonCount = 0;\r\n\r\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\r\n      newPos++;\r\n      oldPos++;\r\n      commonCount++;\r\n    }\r\n\r\n    if (commonCount) {\r\n      basePath.components.push({\r\n        count: commonCount\r\n      });\r\n    }\r\n\r\n    basePath.newPos = newPos;\r\n    return oldPos;\r\n  },\r\n  equals: function equals(left, right) {\r\n    if (this.options.comparator) {\r\n      return this.options.comparator(left, right);\r\n    } else {\r\n      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\r\n    }\r\n  },\r\n  removeEmpty: function removeEmpty(array) {\r\n    var ret = [];\r\n\r\n    for (var i = 0; i < array.length; i++) {\r\n      if (array[i]) {\r\n        ret.push(array[i]);\r\n      }\r\n    }\r\n\r\n    return ret;\r\n  },\r\n  castInput: function castInput(value) {\r\n    return value;\r\n  },\r\n  tokenize: function tokenize(value) {\r\n    return value.split('');\r\n  },\r\n  join: function join(chars) {\r\n    return chars.join('');\r\n  }\r\n};\r\n\r\nfunction buildValues(diff, components, newString, oldString, useLongestToken) {\r\n  var componentPos = 0,\r\n      componentLen = components.length,\r\n      newPos = 0,\r\n      oldPos = 0;\r\n\r\n  for (; componentPos < componentLen; componentPos++) {\r\n    var component = components[componentPos];\r\n\r\n    if (!component.removed) {\r\n      if (!component.added && useLongestToken) {\r\n        var value = newString.slice(newPos, newPos + component.count);\r\n        value = value.map(function (value, i) {\r\n          var oldValue = oldString[oldPos + i];\r\n          return oldValue.length > value.length ? oldValue : value;\r\n        });\r\n        component.value = diff.join(value);\r\n      } else {\r\n        component.value = diff.join(newString.slice(newPos, newPos + component.count));\r\n      }\r\n\r\n      newPos += component.count; // Common case\r\n\r\n      if (!component.added) {\r\n        oldPos += component.count;\r\n      }\r\n    } else {\r\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\r\n      oldPos += component.count; // Reverse add and remove so removes are output first to match common convention\r\n      // The diffing algorithm is tied to add then remove output and this is the simplest\r\n      // route to get the desired output with minimal overhead.\r\n\r\n      if (componentPos && components[componentPos - 1].added) {\r\n        var tmp = components[componentPos - 1];\r\n        components[componentPos - 1] = components[componentPos];\r\n        components[componentPos] = tmp;\r\n      }\r\n    }\r\n  } // Special case handle for when one terminal is ignored (i.e. whitespace).\r\n  // For this case we merge the terminal into the prior string and drop the change.\r\n  // This is only available for string mode.\r\n\r\n\r\n  var lastComponent = components[componentLen - 1];\r\n\r\n  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {\r\n    components[componentLen - 2].value += lastComponent.value;\r\n    components.pop();\r\n  }\r\n\r\n  return components;\r\n}\r\n\r\nfunction clonePath(path) {\r\n  return {\r\n    newPos: path.newPos,\r\n    components: path.components.slice(0)\r\n  };\r\n}\r\n\r\nvar characterDiff = new Diff();\r\nfunction diffChars(oldStr, newStr, options) {\r\n  return characterDiff.diff(oldStr, newStr, options);\r\n}\r\n\r\nfunction generateOptions(options, defaults) {\r\n  if (typeof options === 'function') {\r\n    defaults.callback = options;\r\n  } else if (options) {\r\n    for (var name in options) {\r\n      /* istanbul ignore else */\r\n      if (options.hasOwnProperty(name)) {\r\n        defaults[name] = options[name];\r\n      }\r\n    }\r\n  }\r\n\r\n  return defaults;\r\n}\r\n\r\n//\r\n// Ranges and exceptions:\r\n// Latin-1 Supplement, 0080–00FF\r\n//  - U+00D7  × Multiplication sign\r\n//  - U+00F7  ÷ Division sign\r\n// Latin Extended-A, 0100–017F\r\n// Latin Extended-B, 0180–024F\r\n// IPA Extensions, 0250–02AF\r\n// Spacing Modifier Letters, 02B0–02FF\r\n//  - U+02C7  ˇ &#711;  Caron\r\n//  - U+02D8  ˘ &#728;  Breve\r\n//  - U+02D9  ˙ &#729;  Dot Above\r\n//  - U+02DA  ˚ &#730;  Ring Above\r\n//  - U+02DB  ˛ &#731;  Ogonek\r\n//  - U+02DC  ˜ &#732;  Small Tilde\r\n//  - U+02DD  ˝ &#733;  Double Acute Accent\r\n// Latin Extended Additional, 1E00–1EFF\r\n\r\nvar extendedWordChars = /^[A-Za-z\\xC0-\\u02C6\\u02C8-\\u02D7\\u02DE-\\u02FF\\u1E00-\\u1EFF]+$/;\r\nvar reWhitespace = /\\S/;\r\nvar wordDiff = new Diff();\r\n\r\nwordDiff.equals = function (left, right) {\r\n  if (this.options.ignoreCase) {\r\n    left = left.toLowerCase();\r\n    right = right.toLowerCase();\r\n  }\r\n\r\n  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);\r\n};\r\n\r\nwordDiff.tokenize = function (value) {\r\n  // All whitespace symbols except newline group into one token, each newline - in separate token\r\n  var tokens = value.split(/([^\\S\\r\\n]+|[()[\\]{}'\"\\r\\n]|\\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\r\n\r\n  for (var i = 0; i < tokens.length - 1; i++) {\r\n    // If we have an empty string in the next field and we have only word chars before and after, merge\r\n    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {\r\n      tokens[i] += tokens[i + 2];\r\n      tokens.splice(i + 1, 2);\r\n      i--;\r\n    }\r\n  }\r\n\r\n  return tokens;\r\n};\r\n\r\nfunction diffWords(oldStr, newStr, options) {\r\n  options = generateOptions(options, {\r\n    ignoreWhitespace: true\r\n  });\r\n  return wordDiff.diff(oldStr, newStr, options);\r\n}\r\nfunction diffWordsWithSpace(oldStr, newStr, options) {\r\n  return wordDiff.diff(oldStr, newStr, options);\r\n}\r\n\r\nvar lineDiff = new Diff();\r\n\r\nlineDiff.tokenize = function (value) {\r\n  var retLines = [],\r\n      linesAndNewlines = value.split(/(\\n|\\r\\n)/); // Ignore the final empty token that occurs if the string ends with a new line\r\n\r\n  if (!linesAndNewlines[linesAndNewlines.length - 1]) {\r\n    linesAndNewlines.pop();\r\n  } // Merge the content and line separators into single tokens\r\n\r\n\r\n  for (var i = 0; i < linesAndNewlines.length; i++) {\r\n    var line = linesAndNewlines[i];\r\n\r\n    if (i % 2 && !this.options.newlineIsToken) {\r\n      retLines[retLines.length - 1] += line;\r\n    } else {\r\n      if (this.options.ignoreWhitespace) {\r\n        line = line.trim();\r\n      }\r\n\r\n      retLines.push(line);\r\n    }\r\n  }\r\n\r\n  return retLines;\r\n};\r\n\r\nfunction diffLines(oldStr, newStr, callback) {\r\n  return lineDiff.diff(oldStr, newStr, callback);\r\n}\r\nfunction diffTrimmedLines(oldStr, newStr, callback) {\r\n  var options = generateOptions(callback, {\r\n    ignoreWhitespace: true\r\n  });\r\n  return lineDiff.diff(oldStr, newStr, options);\r\n}\r\n\r\nvar sentenceDiff = new Diff();\r\n\r\nsentenceDiff.tokenize = function (value) {\r\n  return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\r\n};\r\n\r\nfunction diffSentences(oldStr, newStr, callback) {\r\n  return sentenceDiff.diff(oldStr, newStr, callback);\r\n}\r\n\r\nvar cssDiff = new Diff();\r\n\r\ncssDiff.tokenize = function (value) {\r\n  return value.split(/([{}:;,]|\\s+)/);\r\n};\r\n\r\nfunction diffCss(oldStr, newStr, callback) {\r\n  return cssDiff.diff(oldStr, newStr, callback);\r\n}\r\n\r\nfunction _typeof(obj) {\r\n  \"@babel/helpers - typeof\";\r\n\r\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\r\n    _typeof = function (obj) {\r\n      return typeof obj;\r\n    };\r\n  } else {\r\n    _typeof = function (obj) {\r\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\r\n    };\r\n  }\r\n\r\n  return _typeof(obj);\r\n}\r\n\r\nfunction _toConsumableArray(arr) {\r\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\r\n}\r\n\r\nfunction _arrayWithoutHoles(arr) {\r\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\r\n}\r\n\r\nfunction _iterableToArray(iter) {\r\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\r\n}\r\n\r\nfunction _unsupportedIterableToArray(o, minLen) {\r\n  if (!o) return;\r\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\r\n  var n = Object.prototype.toString.call(o).slice(8, -1);\r\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\r\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\r\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\r\n}\r\n\r\nfunction _arrayLikeToArray(arr, len) {\r\n  if (len == null || len > arr.length) len = arr.length;\r\n\r\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\r\n\r\n  return arr2;\r\n}\r\n\r\nfunction _nonIterableSpread() {\r\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\r\n}\r\n\r\nvar objectPrototypeToString = Object.prototype.toString;\r\nvar jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\r\n// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\r\n\r\njsonDiff.useLongestToken = true;\r\njsonDiff.tokenize = lineDiff.tokenize;\r\n\r\njsonDiff.castInput = function (value) {\r\n  var _this$options = this.options,\r\n      undefinedReplacement = _this$options.undefinedReplacement,\r\n      _this$options$stringi = _this$options.stringifyReplacer,\r\n      stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {\r\n    return typeof v === 'undefined' ? undefinedReplacement : v;\r\n  } : _this$options$stringi;\r\n  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\r\n};\r\n\r\njsonDiff.equals = function (left, right) {\r\n  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'));\r\n};\r\n\r\nfunction diffJson(oldObj, newObj, options) {\r\n  return jsonDiff.diff(oldObj, newObj, options);\r\n} // This function handles the presence of circular references by bailing out when encountering an\r\n// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\r\n\r\nfunction canonicalize(obj, stack, replacementStack, replacer, key) {\r\n  stack = stack || [];\r\n  replacementStack = replacementStack || [];\r\n\r\n  if (replacer) {\r\n    obj = replacer(key, obj);\r\n  }\r\n\r\n  var i;\r\n\r\n  for (i = 0; i < stack.length; i += 1) {\r\n    if (stack[i] === obj) {\r\n      return replacementStack[i];\r\n    }\r\n  }\r\n\r\n  var canonicalizedObj;\r\n\r\n  if ('[object Array]' === objectPrototypeToString.call(obj)) {\r\n    stack.push(obj);\r\n    canonicalizedObj = new Array(obj.length);\r\n    replacementStack.push(canonicalizedObj);\r\n\r\n    for (i = 0; i < obj.length; i += 1) {\r\n      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\r\n    }\r\n\r\n    stack.pop();\r\n    replacementStack.pop();\r\n    return canonicalizedObj;\r\n  }\r\n\r\n  if (obj && obj.toJSON) {\r\n    obj = obj.toJSON();\r\n  }\r\n\r\n  if (_typeof(obj) === 'object' && obj !== null) {\r\n    stack.push(obj);\r\n    canonicalizedObj = {};\r\n    replacementStack.push(canonicalizedObj);\r\n\r\n    var sortedKeys = [],\r\n        _key;\r\n\r\n    for (_key in obj) {\r\n      /* istanbul ignore else */\r\n      if (obj.hasOwnProperty(_key)) {\r\n        sortedKeys.push(_key);\r\n      }\r\n    }\r\n\r\n    sortedKeys.sort();\r\n\r\n    for (i = 0; i < sortedKeys.length; i += 1) {\r\n      _key = sortedKeys[i];\r\n      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\r\n    }\r\n\r\n    stack.pop();\r\n    replacementStack.pop();\r\n  } else {\r\n    canonicalizedObj = obj;\r\n  }\r\n\r\n  return canonicalizedObj;\r\n}\r\n\r\nvar arrayDiff = new Diff();\r\n\r\narrayDiff.tokenize = function (value) {\r\n  return value.slice();\r\n};\r\n\r\narrayDiff.join = arrayDiff.removeEmpty = function (value) {\r\n  return value;\r\n};\r\n\r\nfunction diffArrays(oldArr, newArr, callback) {\r\n  return arrayDiff.diff(oldArr, newArr, callback);\r\n}\r\n\r\nfunction parsePatch(uniDiff) {\r\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n  var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\r\n      delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\r\n      list = [],\r\n      i = 0;\r\n\r\n  function parseIndex() {\r\n    var index = {};\r\n    list.push(index); // Parse diff metadata\r\n\r\n    while (i < diffstr.length) {\r\n      var line = diffstr[i]; // File header found, end parsing diff metadata\r\n\r\n      if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\r\n        break;\r\n      } // Diff index\r\n\r\n\r\n      var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\r\n\r\n      if (header) {\r\n        index.index = header[1];\r\n      }\r\n\r\n      i++;\r\n    } // Parse file headers if they are defined. Unified diff requires them, but\r\n    // there's no technical issues to have an isolated hunk without file header\r\n\r\n\r\n    parseFileHeader(index);\r\n    parseFileHeader(index); // Parse hunks\r\n\r\n    index.hunks = [];\r\n\r\n    while (i < diffstr.length) {\r\n      var _line = diffstr[i];\r\n\r\n      if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) {\r\n        break;\r\n      } else if (/^@@/.test(_line)) {\r\n        index.hunks.push(parseHunk());\r\n      } else if (_line && options.strict) {\r\n        // Ignore unexpected content unless in strict mode\r\n        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));\r\n      } else {\r\n        i++;\r\n      }\r\n    }\r\n  } // Parses the --- and +++ headers, if none are found, no lines\r\n  // are consumed.\r\n\r\n\r\n  function parseFileHeader(index) {\r\n    var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)$/.exec(diffstr[i]);\r\n\r\n    if (fileHeader) {\r\n      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\r\n      var data = fileHeader[2].split('\\t', 2);\r\n      var fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\r\n\r\n      if (/^\".*\"$/.test(fileName)) {\r\n        fileName = fileName.substr(1, fileName.length - 2);\r\n      }\r\n\r\n      index[keyPrefix + 'FileName'] = fileName;\r\n      index[keyPrefix + 'Header'] = (data[1] || '').trim();\r\n      i++;\r\n    }\r\n  } // Parses a hunk\r\n  // This assumes that we are at the start of a hunk.\r\n\r\n\r\n  function parseHunk() {\r\n    var chunkHeaderIndex = i,\r\n        chunkHeaderLine = diffstr[i++],\r\n        chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\r\n    var hunk = {\r\n      oldStart: +chunkHeader[1],\r\n      oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\r\n      newStart: +chunkHeader[3],\r\n      newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\r\n      lines: [],\r\n      linedelimiters: []\r\n    }; // Unified Diff Format quirk: If the chunk size is 0,\r\n    // the first number is one lower than one would expect.\r\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\r\n\r\n    if (hunk.oldLines === 0) {\r\n      hunk.oldStart += 1;\r\n    }\r\n\r\n    if (hunk.newLines === 0) {\r\n      hunk.newStart += 1;\r\n    }\r\n\r\n    var addCount = 0,\r\n        removeCount = 0;\r\n\r\n    for (; i < diffstr.length; i++) {\r\n      // Lines starting with '---' could be mistaken for the \"remove line\" operation\r\n      // But they could be the header for the next file. Therefore prune such cases out.\r\n      if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {\r\n        break;\r\n      }\r\n\r\n      var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];\r\n\r\n      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\r\n        hunk.lines.push(diffstr[i]);\r\n        hunk.linedelimiters.push(delimiters[i] || '\\n');\r\n\r\n        if (operation === '+') {\r\n          addCount++;\r\n        } else if (operation === '-') {\r\n          removeCount++;\r\n        } else if (operation === ' ') {\r\n          addCount++;\r\n          removeCount++;\r\n        }\r\n      } else {\r\n        break;\r\n      }\r\n    } // Handle the empty block count case\r\n\r\n\r\n    if (!addCount && hunk.newLines === 1) {\r\n      hunk.newLines = 0;\r\n    }\r\n\r\n    if (!removeCount && hunk.oldLines === 1) {\r\n      hunk.oldLines = 0;\r\n    } // Perform optional sanity checking\r\n\r\n\r\n    if (options.strict) {\r\n      if (addCount !== hunk.newLines) {\r\n        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\r\n      }\r\n\r\n      if (removeCount !== hunk.oldLines) {\r\n        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\r\n      }\r\n    }\r\n\r\n    return hunk;\r\n  }\r\n\r\n  while (i < diffstr.length) {\r\n    parseIndex();\r\n  }\r\n\r\n  return list;\r\n}\r\n\r\n// Iterator that traverses in the range of [min, max], stepping\r\n// by distance from a given start position. I.e. for [0, 4], with\r\n// start of 2, this will iterate 2, 3, 1, 4, 0.\r\nfunction distanceIterator (start, minLine, maxLine) {\r\n  var wantForward = true,\r\n      backwardExhausted = false,\r\n      forwardExhausted = false,\r\n      localOffset = 1;\r\n  return function iterator() {\r\n    if (wantForward && !forwardExhausted) {\r\n      if (backwardExhausted) {\r\n        localOffset++;\r\n      } else {\r\n        wantForward = false;\r\n      } // Check if trying to fit beyond text length, and if not, check it fits\r\n      // after offset location (or desired location on first iteration)\r\n\r\n\r\n      if (start + localOffset <= maxLine) {\r\n        return localOffset;\r\n      }\r\n\r\n      forwardExhausted = true;\r\n    }\r\n\r\n    if (!backwardExhausted) {\r\n      if (!forwardExhausted) {\r\n        wantForward = true;\r\n      } // Check if trying to fit before text beginning, and if not, check it fits\r\n      // before offset location\r\n\r\n\r\n      if (minLine <= start - localOffset) {\r\n        return -localOffset++;\r\n      }\r\n\r\n      backwardExhausted = true;\r\n      return iterator();\r\n    } // We tried to fit hunk before text beginning and beyond text length, then\r\n    // hunk can't fit on the text. Return undefined\r\n\r\n  };\r\n}\r\n\r\nfunction applyPatch(source, uniDiff) {\r\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\r\n\r\n  if (typeof uniDiff === 'string') {\r\n    uniDiff = parsePatch(uniDiff);\r\n  }\r\n\r\n  if (Array.isArray(uniDiff)) {\r\n    if (uniDiff.length > 1) {\r\n      throw new Error('applyPatch only works with a single input.');\r\n    }\r\n\r\n    uniDiff = uniDiff[0];\r\n  } // Apply the diff to the input\r\n\r\n\r\n  var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\r\n      delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\r\n      hunks = uniDiff.hunks,\r\n      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) {\r\n    return line === patchContent;\r\n  },\r\n      errorCount = 0,\r\n      fuzzFactor = options.fuzzFactor || 0,\r\n      minLine = 0,\r\n      offset = 0,\r\n      removeEOFNL,\r\n      addEOFNL;\r\n  /**\r\n   * Checks if the hunk exactly fits on the provided location\r\n   */\r\n\r\n\r\n  function hunkFits(hunk, toPos) {\r\n    for (var j = 0; j < hunk.lines.length; j++) {\r\n      var line = hunk.lines[j],\r\n          operation = line.length > 0 ? line[0] : ' ',\r\n          content = line.length > 0 ? line.substr(1) : line;\r\n\r\n      if (operation === ' ' || operation === '-') {\r\n        // Context sanity check\r\n        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\r\n          errorCount++;\r\n\r\n          if (errorCount > fuzzFactor) {\r\n            return false;\r\n          }\r\n        }\r\n\r\n        toPos++;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  } // Search best fit offsets for each hunk based on the previous ones\r\n\r\n\r\n  for (var i = 0; i < hunks.length; i++) {\r\n    var hunk = hunks[i],\r\n        maxLine = lines.length - hunk.oldLines,\r\n        localOffset = 0,\r\n        toPos = offset + hunk.oldStart - 1;\r\n    var iterator = distanceIterator(toPos, minLine, maxLine);\r\n\r\n    for (; localOffset !== undefined; localOffset = iterator()) {\r\n      if (hunkFits(hunk, toPos + localOffset)) {\r\n        hunk.offset = offset += localOffset;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (localOffset === undefined) {\r\n      return false;\r\n    } // Set lower text limit to end of the current hunk, so next ones don't try\r\n    // to fit over already patched text\r\n\r\n\r\n    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\r\n  } // Apply patch hunks\r\n\r\n\r\n  var diffOffset = 0;\r\n\r\n  for (var _i = 0; _i < hunks.length; _i++) {\r\n    var _hunk = hunks[_i],\r\n        _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;\r\n\r\n    diffOffset += _hunk.newLines - _hunk.oldLines;\r\n\r\n    for (var j = 0; j < _hunk.lines.length; j++) {\r\n      var line = _hunk.lines[j],\r\n          operation = line.length > 0 ? line[0] : ' ',\r\n          content = line.length > 0 ? line.substr(1) : line,\r\n          delimiter = _hunk.linedelimiters[j];\r\n\r\n      if (operation === ' ') {\r\n        _toPos++;\r\n      } else if (operation === '-') {\r\n        lines.splice(_toPos, 1);\r\n        delimiters.splice(_toPos, 1);\r\n        /* istanbul ignore else */\r\n      } else if (operation === '+') {\r\n        lines.splice(_toPos, 0, content);\r\n        delimiters.splice(_toPos, 0, delimiter);\r\n        _toPos++;\r\n      } else if (operation === '\\\\') {\r\n        var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\r\n\r\n        if (previousOperation === '+') {\r\n          removeEOFNL = true;\r\n        } else if (previousOperation === '-') {\r\n          addEOFNL = true;\r\n        }\r\n      }\r\n    }\r\n  } // Handle EOFNL insertion/removal\r\n\r\n\r\n  if (removeEOFNL) {\r\n    while (!lines[lines.length - 1]) {\r\n      lines.pop();\r\n      delimiters.pop();\r\n    }\r\n  } else if (addEOFNL) {\r\n    lines.push('');\r\n    delimiters.push('\\n');\r\n  }\r\n\r\n  for (var _k = 0; _k < lines.length - 1; _k++) {\r\n    lines[_k] = lines[_k] + delimiters[_k];\r\n  }\r\n\r\n  return lines.join('');\r\n} // Wrapper that supports multiple file patches via callbacks.\r\n\r\nfunction applyPatches(uniDiff, options) {\r\n  if (typeof uniDiff === 'string') {\r\n    uniDiff = parsePatch(uniDiff);\r\n  }\r\n\r\n  var currentIndex = 0;\r\n\r\n  function processIndex() {\r\n    var index = uniDiff[currentIndex++];\r\n\r\n    if (!index) {\r\n      return options.complete();\r\n    }\r\n\r\n    options.loadFile(index, function (err, data) {\r\n      if (err) {\r\n        return options.complete(err);\r\n      }\r\n\r\n      var updatedContent = applyPatch(data, index, options);\r\n      options.patched(index, updatedContent, function (err) {\r\n        if (err) {\r\n          return options.complete(err);\r\n        }\r\n\r\n        processIndex();\r\n      });\r\n    });\r\n  }\r\n\r\n  processIndex();\r\n}\r\n\r\nfunction structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\r\n  if (!options) {\r\n    options = {};\r\n  }\r\n\r\n  if (typeof options.context === 'undefined') {\r\n    options.context = 4;\r\n  }\r\n\r\n  var diff = diffLines(oldStr, newStr, options);\r\n\r\n  if (!diff) {\r\n    return;\r\n  }\r\n\r\n  diff.push({\r\n    value: '',\r\n    lines: []\r\n  }); // Append an empty value to make cleanup easier\r\n\r\n  function contextLines(lines) {\r\n    return lines.map(function (entry) {\r\n      return ' ' + entry;\r\n    });\r\n  }\r\n\r\n  var hunks = [];\r\n  var oldRangeStart = 0,\r\n      newRangeStart = 0,\r\n      curRange = [],\r\n      oldLine = 1,\r\n      newLine = 1;\r\n\r\n  var _loop = function _loop(i) {\r\n    var current = diff[i],\r\n        lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\r\n    current.lines = lines;\r\n\r\n    if (current.added || current.removed) {\r\n      var _curRange;\r\n\r\n      // If we have previous context, start with that\r\n      if (!oldRangeStart) {\r\n        var prev = diff[i - 1];\r\n        oldRangeStart = oldLine;\r\n        newRangeStart = newLine;\r\n\r\n        if (prev) {\r\n          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\r\n          oldRangeStart -= curRange.length;\r\n          newRangeStart -= curRange.length;\r\n        }\r\n      } // Output our changes\r\n\r\n\r\n      (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function (entry) {\r\n        return (current.added ? '+' : '-') + entry;\r\n      }))); // Track the updated file position\r\n\r\n\r\n      if (current.added) {\r\n        newLine += lines.length;\r\n      } else {\r\n        oldLine += lines.length;\r\n      }\r\n    } else {\r\n      // Identical context lines. Track line changes\r\n      if (oldRangeStart) {\r\n        // Close out any changes that have been output (or join overlapping)\r\n        if (lines.length <= options.context * 2 && i < diff.length - 2) {\r\n          var _curRange2;\r\n\r\n          // Overlapping\r\n          (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));\r\n        } else {\r\n          var _curRange3;\r\n\r\n          // end the range and output\r\n          var contextSize = Math.min(lines.length, options.context);\r\n\r\n          (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));\r\n\r\n          var hunk = {\r\n            oldStart: oldRangeStart,\r\n            oldLines: oldLine - oldRangeStart + contextSize,\r\n            newStart: newRangeStart,\r\n            newLines: newLine - newRangeStart + contextSize,\r\n            lines: curRange\r\n          };\r\n\r\n          if (i >= diff.length - 2 && lines.length <= options.context) {\r\n            // EOF is inside this hunk\r\n            var oldEOFNewline = /\\n$/.test(oldStr);\r\n            var newEOFNewline = /\\n$/.test(newStr);\r\n            var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;\r\n\r\n            if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {\r\n              // special case: old has no eol and no trailing context; no-nl can end up before adds\r\n              // however, if the old file is empty, do not output the no-nl line\r\n              curRange.splice(hunk.oldLines, 0, '\\\\ No newline at end of file');\r\n            }\r\n\r\n            if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {\r\n              curRange.push('\\\\ No newline at end of file');\r\n            }\r\n          }\r\n\r\n          hunks.push(hunk);\r\n          oldRangeStart = 0;\r\n          newRangeStart = 0;\r\n          curRange = [];\r\n        }\r\n      }\r\n\r\n      oldLine += lines.length;\r\n      newLine += lines.length;\r\n    }\r\n  };\r\n\r\n  for (var i = 0; i < diff.length; i++) {\r\n    _loop(i);\r\n  }\r\n\r\n  return {\r\n    oldFileName: oldFileName,\r\n    newFileName: newFileName,\r\n    oldHeader: oldHeader,\r\n    newHeader: newHeader,\r\n    hunks: hunks\r\n  };\r\n}\r\nfunction formatPatch(diff) {\r\n  var ret = [];\r\n\r\n  if (diff.oldFileName == diff.newFileName) {\r\n    ret.push('Index: ' + diff.oldFileName);\r\n  }\r\n\r\n  ret.push('===================================================================');\r\n  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\r\n  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\r\n\r\n  for (var i = 0; i < diff.hunks.length; i++) {\r\n    var hunk = diff.hunks[i]; // Unified Diff Format quirk: If the chunk size is 0,\r\n    // the first number is one lower than one would expect.\r\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\r\n\r\n    if (hunk.oldLines === 0) {\r\n      hunk.oldStart -= 1;\r\n    }\r\n\r\n    if (hunk.newLines === 0) {\r\n      hunk.newStart -= 1;\r\n    }\r\n\r\n    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');\r\n    ret.push.apply(ret, hunk.lines);\r\n  }\r\n\r\n  return ret.join('\\n') + '\\n';\r\n}\r\nfunction createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\r\n  return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));\r\n}\r\nfunction createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\r\n  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\r\n}\r\n\r\nfunction arrayEqual(a, b) {\r\n  if (a.length !== b.length) {\r\n    return false;\r\n  }\r\n\r\n  return arrayStartsWith(a, b);\r\n}\r\nfunction arrayStartsWith(array, start) {\r\n  if (start.length > array.length) {\r\n    return false;\r\n  }\r\n\r\n  for (var i = 0; i < start.length; i++) {\r\n    if (start[i] !== array[i]) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction calcLineCount(hunk) {\r\n  var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines),\r\n      oldLines = _calcOldNewLineCount.oldLines,\r\n      newLines = _calcOldNewLineCount.newLines;\r\n\r\n  if (oldLines !== undefined) {\r\n    hunk.oldLines = oldLines;\r\n  } else {\r\n    delete hunk.oldLines;\r\n  }\r\n\r\n  if (newLines !== undefined) {\r\n    hunk.newLines = newLines;\r\n  } else {\r\n    delete hunk.newLines;\r\n  }\r\n}\r\nfunction merge(mine, theirs, base) {\r\n  mine = loadPatch(mine, base);\r\n  theirs = loadPatch(theirs, base);\r\n  var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.\r\n  // Leaving sanity checks on this to the API consumer that may know more about the\r\n  // meaning in their own context.\r\n\r\n  if (mine.index || theirs.index) {\r\n    ret.index = mine.index || theirs.index;\r\n  }\r\n\r\n  if (mine.newFileName || theirs.newFileName) {\r\n    if (!fileNameChanged(mine)) {\r\n      // No header or no change in ours, use theirs (and ours if theirs does not exist)\r\n      ret.oldFileName = theirs.oldFileName || mine.oldFileName;\r\n      ret.newFileName = theirs.newFileName || mine.newFileName;\r\n      ret.oldHeader = theirs.oldHeader || mine.oldHeader;\r\n      ret.newHeader = theirs.newHeader || mine.newHeader;\r\n    } else if (!fileNameChanged(theirs)) {\r\n      // No header or no change in theirs, use ours\r\n      ret.oldFileName = mine.oldFileName;\r\n      ret.newFileName = mine.newFileName;\r\n      ret.oldHeader = mine.oldHeader;\r\n      ret.newHeader = mine.newHeader;\r\n    } else {\r\n      // Both changed... figure it out\r\n      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\r\n      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\r\n      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\r\n      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\r\n    }\r\n  }\r\n\r\n  ret.hunks = [];\r\n  var mineIndex = 0,\r\n      theirsIndex = 0,\r\n      mineOffset = 0,\r\n      theirsOffset = 0;\r\n\r\n  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\r\n    var mineCurrent = mine.hunks[mineIndex] || {\r\n      oldStart: Infinity\r\n    },\r\n        theirsCurrent = theirs.hunks[theirsIndex] || {\r\n      oldStart: Infinity\r\n    };\r\n\r\n    if (hunkBefore(mineCurrent, theirsCurrent)) {\r\n      // This patch does not overlap with any of the others, yay.\r\n      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\r\n      mineIndex++;\r\n      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\r\n    } else if (hunkBefore(theirsCurrent, mineCurrent)) {\r\n      // This patch does not overlap with any of the others, yay.\r\n      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\r\n      theirsIndex++;\r\n      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\r\n    } else {\r\n      // Overlap, merge as best we can\r\n      var mergedHunk = {\r\n        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\r\n        oldLines: 0,\r\n        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\r\n        newLines: 0,\r\n        lines: []\r\n      };\r\n      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\r\n      theirsIndex++;\r\n      mineIndex++;\r\n      ret.hunks.push(mergedHunk);\r\n    }\r\n  }\r\n\r\n  return ret;\r\n}\r\n\r\nfunction loadPatch(param, base) {\r\n  if (typeof param === 'string') {\r\n    if (/^@@/m.test(param) || /^Index:/m.test(param)) {\r\n      return parsePatch(param)[0];\r\n    }\r\n\r\n    if (!base) {\r\n      throw new Error('Must provide a base reference or pass in a patch');\r\n    }\r\n\r\n    return structuredPatch(undefined, undefined, base, param);\r\n  }\r\n\r\n  return param;\r\n}\r\n\r\nfunction fileNameChanged(patch) {\r\n  return patch.newFileName && patch.newFileName !== patch.oldFileName;\r\n}\r\n\r\nfunction selectField(index, mine, theirs) {\r\n  if (mine === theirs) {\r\n    return mine;\r\n  } else {\r\n    index.conflict = true;\r\n    return {\r\n      mine: mine,\r\n      theirs: theirs\r\n    };\r\n  }\r\n}\r\n\r\nfunction hunkBefore(test, check) {\r\n  return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\r\n}\r\n\r\nfunction cloneHunk(hunk, offset) {\r\n  return {\r\n    oldStart: hunk.oldStart,\r\n    oldLines: hunk.oldLines,\r\n    newStart: hunk.newStart + offset,\r\n    newLines: hunk.newLines,\r\n    lines: hunk.lines\r\n  };\r\n}\r\n\r\nfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\r\n  // This will generally result in a conflicted hunk, but there are cases where the context\r\n  // is the only overlap where we can successfully merge the content here.\r\n  var mine = {\r\n    offset: mineOffset,\r\n    lines: mineLines,\r\n    index: 0\r\n  },\r\n      their = {\r\n    offset: theirOffset,\r\n    lines: theirLines,\r\n    index: 0\r\n  }; // Handle any leading content\r\n\r\n  insertLeading(hunk, mine, their);\r\n  insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.\r\n\r\n  while (mine.index < mine.lines.length && their.index < their.lines.length) {\r\n    var mineCurrent = mine.lines[mine.index],\r\n        theirCurrent = their.lines[their.index];\r\n\r\n    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\r\n      // Both modified ...\r\n      mutualChange(hunk, mine, their);\r\n    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\r\n      var _hunk$lines;\r\n\r\n      // Mine inserted\r\n      (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));\r\n    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\r\n      var _hunk$lines2;\r\n\r\n      // Theirs inserted\r\n      (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));\r\n    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\r\n      // Mine removed or edited\r\n      removal(hunk, mine, their);\r\n    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\r\n      // Their removed or edited\r\n      removal(hunk, their, mine, true);\r\n    } else if (mineCurrent === theirCurrent) {\r\n      // Context identity\r\n      hunk.lines.push(mineCurrent);\r\n      mine.index++;\r\n      their.index++;\r\n    } else {\r\n      // Context mismatch\r\n      conflict(hunk, collectChange(mine), collectChange(their));\r\n    }\r\n  } // Now push anything that may be remaining\r\n\r\n\r\n  insertTrailing(hunk, mine);\r\n  insertTrailing(hunk, their);\r\n  calcLineCount(hunk);\r\n}\r\n\r\nfunction mutualChange(hunk, mine, their) {\r\n  var myChanges = collectChange(mine),\r\n      theirChanges = collectChange(their);\r\n\r\n  if (allRemoves(myChanges) && allRemoves(theirChanges)) {\r\n    // Special case for remove changes that are supersets of one another\r\n    if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\r\n      var _hunk$lines3;\r\n\r\n      (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));\r\n\r\n      return;\r\n    } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\r\n      var _hunk$lines4;\r\n\r\n      (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));\r\n\r\n      return;\r\n    }\r\n  } else if (arrayEqual(myChanges, theirChanges)) {\r\n    var _hunk$lines5;\r\n\r\n    (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));\r\n\r\n    return;\r\n  }\r\n\r\n  conflict(hunk, myChanges, theirChanges);\r\n}\r\n\r\nfunction removal(hunk, mine, their, swap) {\r\n  var myChanges = collectChange(mine),\r\n      theirChanges = collectContext(their, myChanges);\r\n\r\n  if (theirChanges.merged) {\r\n    var _hunk$lines6;\r\n\r\n    (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));\r\n  } else {\r\n    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\r\n  }\r\n}\r\n\r\nfunction conflict(hunk, mine, their) {\r\n  hunk.conflict = true;\r\n  hunk.lines.push({\r\n    conflict: true,\r\n    mine: mine,\r\n    theirs: their\r\n  });\r\n}\r\n\r\nfunction insertLeading(hunk, insert, their) {\r\n  while (insert.offset < their.offset && insert.index < insert.lines.length) {\r\n    var line = insert.lines[insert.index++];\r\n    hunk.lines.push(line);\r\n    insert.offset++;\r\n  }\r\n}\r\n\r\nfunction insertTrailing(hunk, insert) {\r\n  while (insert.index < insert.lines.length) {\r\n    var line = insert.lines[insert.index++];\r\n    hunk.lines.push(line);\r\n  }\r\n}\r\n\r\nfunction collectChange(state) {\r\n  var ret = [],\r\n      operation = state.lines[state.index][0];\r\n\r\n  while (state.index < state.lines.length) {\r\n    var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\r\n\r\n    if (operation === '-' && line[0] === '+') {\r\n      operation = '+';\r\n    }\r\n\r\n    if (operation === line[0]) {\r\n      ret.push(line);\r\n      state.index++;\r\n    } else {\r\n      break;\r\n    }\r\n  }\r\n\r\n  return ret;\r\n}\r\n\r\nfunction collectContext(state, matchChanges) {\r\n  var changes = [],\r\n      merged = [],\r\n      matchIndex = 0,\r\n      contextChanges = false,\r\n      conflicted = false;\r\n\r\n  while (matchIndex < matchChanges.length && state.index < state.lines.length) {\r\n    var change = state.lines[state.index],\r\n        match = matchChanges[matchIndex]; // Once we've hit our add, then we are done\r\n\r\n    if (match[0] === '+') {\r\n      break;\r\n    }\r\n\r\n    contextChanges = contextChanges || change[0] !== ' ';\r\n    merged.push(match);\r\n    matchIndex++; // Consume any additions in the other block as a conflict to attempt\r\n    // to pull in the remaining context after this\r\n\r\n    if (change[0] === '+') {\r\n      conflicted = true;\r\n\r\n      while (change[0] === '+') {\r\n        changes.push(change);\r\n        change = state.lines[++state.index];\r\n      }\r\n    }\r\n\r\n    if (match.substr(1) === change.substr(1)) {\r\n      changes.push(change);\r\n      state.index++;\r\n    } else {\r\n      conflicted = true;\r\n    }\r\n  }\r\n\r\n  if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {\r\n    conflicted = true;\r\n  }\r\n\r\n  if (conflicted) {\r\n    return changes;\r\n  }\r\n\r\n  while (matchIndex < matchChanges.length) {\r\n    merged.push(matchChanges[matchIndex++]);\r\n  }\r\n\r\n  return {\r\n    merged: merged,\r\n    changes: changes\r\n  };\r\n}\r\n\r\nfunction allRemoves(changes) {\r\n  return changes.reduce(function (prev, change) {\r\n    return prev && change[0] === '-';\r\n  }, true);\r\n}\r\n\r\nfunction skipRemoveSuperset(state, removeChanges, delta) {\r\n  for (var i = 0; i < delta; i++) {\r\n    var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\r\n\r\n    if (state.lines[state.index + i] !== ' ' + changeContent) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  state.index += delta;\r\n  return true;\r\n}\r\n\r\nfunction calcOldNewLineCount(lines) {\r\n  var oldLines = 0;\r\n  var newLines = 0;\r\n  lines.forEach(function (line) {\r\n    if (typeof line !== 'string') {\r\n      var myCount = calcOldNewLineCount(line.mine);\r\n      var theirCount = calcOldNewLineCount(line.theirs);\r\n\r\n      if (oldLines !== undefined) {\r\n        if (myCount.oldLines === theirCount.oldLines) {\r\n          oldLines += myCount.oldLines;\r\n        } else {\r\n          oldLines = undefined;\r\n        }\r\n      }\r\n\r\n      if (newLines !== undefined) {\r\n        if (myCount.newLines === theirCount.newLines) {\r\n          newLines += myCount.newLines;\r\n        } else {\r\n          newLines = undefined;\r\n        }\r\n      }\r\n    } else {\r\n      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\r\n        newLines++;\r\n      }\r\n\r\n      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\r\n        oldLines++;\r\n      }\r\n    }\r\n  });\r\n  return {\r\n    oldLines: oldLines,\r\n    newLines: newLines\r\n  };\r\n}\r\n\r\n// See: http://code.google.com/p/google-diff-match-patch/wiki/API\r\nfunction convertChangesToDMP(changes) {\r\n  var ret = [],\r\n      change,\r\n      operation;\r\n\r\n  for (var i = 0; i < changes.length; i++) {\r\n    change = changes[i];\r\n\r\n    if (change.added) {\r\n      operation = 1;\r\n    } else if (change.removed) {\r\n      operation = -1;\r\n    } else {\r\n      operation = 0;\r\n    }\r\n\r\n    ret.push([operation, change.value]);\r\n  }\r\n\r\n  return ret;\r\n}\r\n\r\nfunction convertChangesToXML(changes) {\r\n  var ret = [];\r\n\r\n  for (var i = 0; i < changes.length; i++) {\r\n    var change = changes[i];\r\n\r\n    if (change.added) {\r\n      ret.push('<ins>');\r\n    } else if (change.removed) {\r\n      ret.push('<del>');\r\n    }\r\n\r\n    ret.push(escapeHTML(change.value));\r\n\r\n    if (change.added) {\r\n      ret.push('</ins>');\r\n    } else if (change.removed) {\r\n      ret.push('</del>');\r\n    }\r\n  }\r\n\r\n  return ret.join('');\r\n}\r\n\r\nfunction escapeHTML(s) {\r\n  var n = s;\r\n  n = n.replace(/&/g, '&amp;');\r\n  n = n.replace(/</g, '&lt;');\r\n  n = n.replace(/>/g, '&gt;');\r\n  n = n.replace(/\"/g, '&quot;');\r\n  return n;\r\n}\r\n\r\nexport { Diff, applyPatch, applyPatches, canonicalize, convertChangesToDMP, convertChangesToXML, createPatch, createTwoFilesPatch, diffArrays, diffChars, diffCss, diffJson, diffLines, diffSentences, diffTrimmedLines, diffWords, diffWordsWithSpace, merge, parsePatch, structuredPatch };\r\n", "import kleur from 'kleur';\r\nimport * as diff from 'diff';\r\n\r\nconst colors = {\r\n\t'--': kleur.red,\r\n\t'··': kleur.grey,\r\n\t'++': kleur.green,\r\n};\r\n\r\nconst TITLE = kleur.dim().italic;\r\nconst TAB=kleur.dim('→'), SPACE=kleur.dim('·'), NL=kleur.dim('↵');\r\nconst LOG = (sym, str) => colors[sym](sym + PRETTY(str)) + '\\n';\r\nconst LINE = (num, x) => kleur.dim('L' + String(num).padStart(x, '0') + ' ');\r\nconst PRETTY = str => str.replace(/[ ]/g, SPACE).replace(/\\t/g, TAB).replace(/(\\r?\\n)/g, NL);\r\n\r\nfunction line(obj, prev, pad) {\r\n\tlet char = obj.removed ? '--' : obj.added ? '++' : '··';\r\n\tlet arr = obj.value.replace(/\\r?\\n$/, '').split('\\n');\r\n\tlet i=0, tmp, out='';\r\n\r\n\tif (obj.added) out += colors[char]().underline(TITLE('Expected:')) + '\\n';\r\n\telse if (obj.removed) out += colors[char]().underline(TITLE('Actual:')) + '\\n';\r\n\r\n\tfor (; i < arr.length; i++) {\r\n\t\ttmp = arr[i];\r\n\t\tif (tmp != null) {\r\n\t\t\tif (prev) out += LINE(prev + i, pad);\r\n\t\t\tout += LOG(char, tmp || '\\n');\r\n\t\t}\r\n\t}\r\n\r\n\treturn out;\r\n}\r\n\r\n// TODO: want better diffing\r\n//~> complex items bail outright\r\nexport function arrays(input, expect) {\r\n\tlet arr = diff.diffArrays(input, expect);\r\n\tlet i=0, j=0, k=0, tmp, val, char, isObj, str;\r\n\tlet out = LOG('··', '[');\r\n\r\n\tfor (; i < arr.length; i++) {\r\n\t\tchar = (tmp = arr[i]).removed ? '--' : tmp.added ? '++' : '··';\r\n\r\n\t\tif (tmp.added) {\r\n\t\t\tout += colors[char]().underline(TITLE('Expected:')) + '\\n';\r\n\t\t} else if (tmp.removed) {\r\n\t\t\tout += colors[char]().underline(TITLE('Actual:')) + '\\n';\r\n\t\t}\r\n\r\n\t\tfor (j=0; j < tmp.value.length; j++) {\r\n\t\t\tisObj = (tmp.value[j] && typeof tmp.value[j] === 'object');\r\n\t\t\tval = stringify(tmp.value[j]).split(/\\r?\\n/g);\r\n\t\t\tfor (k=0; k < val.length;) {\r\n\t\t\t\tstr = '  ' + val[k++] + (isObj ? '' : ',');\r\n\t\t\t\tif (isObj && k === val.length && (j + 1) < tmp.value.length) str += ',';\r\n\t\t\t\tout += LOG(char, str);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn out + LOG('··', ']');\r\n}\r\n\r\nexport function lines(input, expect, linenum = 0) {\r\n\tlet i=0, tmp, output='';\r\n\tlet arr = diff.diffLines(input, expect);\r\n\tlet pad = String(expect.split(/\\r?\\n/g).length - linenum).length;\r\n\r\n\tfor (; i < arr.length; i++) {\r\n\t\toutput += line(tmp = arr[i], linenum, pad);\r\n\t\tif (linenum && !tmp.removed) linenum += tmp.count;\r\n\t}\r\n\r\n\treturn output;\r\n}\r\n\r\nexport function chars(input, expect) {\r\n\tlet arr = diff.diffChars(input, expect);\r\n\tlet i=0, output='', tmp;\r\n\r\n\tlet l1 = input.length;\r\n\tlet l2 = expect.length;\r\n\r\n\tlet p1 = PRETTY(input);\r\n\tlet p2 = PRETTY(expect);\r\n\r\n\ttmp = arr[i];\r\n\r\n\tif (l1 === l2) {\r\n\t\t// no length offsets\r\n\t} else if (tmp.removed && arr[i + 1]) {\r\n\t\tlet del = tmp.count - arr[i + 1].count;\r\n\t\tif (del == 0) {\r\n\t\t\t// wash~\r\n\t\t} else if (del > 0) {\r\n\t\t\texpect = ' '.repeat(del) + expect;\r\n\t\t\tp2 = ' '.repeat(del) + p2;\r\n\t\t\tl2 += del;\r\n\t\t} else if (del < 0) {\r\n\t\t\tinput = ' '.repeat(-del) + input;\r\n\t\t\tp1 = ' '.repeat(-del) + p1;\r\n\t\t\tl1 += -del;\r\n\t\t}\r\n\t}\r\n\r\n\toutput += direct(p1, p2, l1, l2);\r\n\r\n\tif (l1 === l2) {\r\n\t\tfor (tmp='  '; i < l1; i++) {\r\n\t\t\ttmp += input[i] === expect[i] ? ' ' : '^';\r\n\t\t}\r\n\t} else {\r\n\t\tfor (tmp='  '; i < arr.length; i++) {\r\n\t\t\ttmp += ((arr[i].added || arr[i].removed) ? '^' : ' ').repeat(Math.max(arr[i].count, 0));\r\n\t\t\tif (i + 1 < arr.length && ((arr[i].added && arr[i+1].removed) || (arr[i].removed && arr[i+1].added))) {\r\n\t\t\t\tarr[i + 1].count -= arr[i].count;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn output + kleur.red(tmp);\r\n}\r\n\r\nexport function direct(input, expect, lenA = String(input).length, lenB = String(expect).length) {\r\n\tlet gutter = 4;\r\n\tlet lenC = Math.max(lenA, lenB);\r\n\tlet typeA=typeof input, typeB=typeof expect;\r\n\r\n\tif (typeA !== typeB) {\r\n\t\tgutter = 2;\r\n\r\n\t\tlet delA = gutter + lenC - lenA;\r\n\t\tlet delB = gutter + lenC - lenB;\r\n\r\n\t\tinput += ' '.repeat(delA) + kleur.dim(`[${typeA}]`);\r\n\t\texpect += ' '.repeat(delB) + kleur.dim(`[${typeB}]`);\r\n\r\n\t\tlenA += delA + typeA.length + 2;\r\n\t\tlenB += delB + typeB.length + 2;\r\n\t\tlenC = Math.max(lenA, lenB);\r\n\t}\r\n\r\n\tlet output = colors['++']('++' + expect + ' '.repeat(gutter + lenC - lenB) + TITLE('(Expected)')) + '\\n';\r\n\treturn output + colors['--']('--' + input + ' '.repeat(gutter + lenC - lenA) + TITLE('(Actual)')) + '\\n';\r\n}\r\n\r\nexport function sort(input, expect) {\r\n\tvar k, i=0, tmp, isArr = Array.isArray(input);\r\n\tvar keys=[], out=isArr ? Array(input.length) : {};\r\n\r\n\tif (isArr) {\r\n\t\tfor (i=0; i < out.length; i++) {\r\n\t\t\ttmp = input[i];\r\n\t\t\tif (!tmp || typeof tmp !== 'object') out[i] = tmp;\r\n\t\t\telse out[i] = sort(tmp, expect[i]); // might not be right\r\n\t\t}\r\n\t} else {\r\n\t\tfor (k in expect)\r\n\t\t\tkeys.push(k);\r\n\r\n\t\tfor (; i < keys.length; i++) {\r\n\t\t\tif (Object.prototype.hasOwnProperty.call(input, k = keys[i])) {\r\n\t\t\t\tif (!(tmp = input[k]) || typeof tmp !== 'object') out[k] = tmp;\r\n\t\t\t\telse out[k] = sort(tmp, expect[k]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (k in input) {\r\n\t\t\tif (!out.hasOwnProperty(k)) {\r\n\t\t\t\tout[k] = input[k]; // expect didnt have\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn out;\r\n}\r\n\r\nexport function circular() {\r\n\tvar cache = new Set;\r\n\treturn function print(key, val) {\r\n\t\tif (val === void 0) return '[__VOID__]';\r\n\t\tif (typeof val === 'number' && val !== val) return '[__NAN__]';\r\n\t\tif (typeof val === 'bigint') return val.toString();\r\n\t\tif (!val || typeof val !== 'object') return val;\r\n\t\tif (cache.has(val)) return '[Circular]';\r\n\t\tcache.add(val); return val;\r\n\t}\r\n}\r\n\r\nexport function stringify(input) {\r\n\treturn JSON.stringify(input, circular(), 2).replace(/\"\\[__NAN__\\]\"/g, 'NaN').replace(/\"\\[__VOID__\\]\"/g, 'undefined');\r\n}\r\n\r\nexport function compare(input, expect) {\r\n\tif (Array.isArray(expect) && Array.isArray(input)) return arrays(input, expect);\r\n\tif (expect instanceof RegExp) return chars(''+input, ''+expect);\r\n\r\n\tlet isA = input && typeof input == 'object';\r\n\tlet isB = expect && typeof expect == 'object';\r\n\r\n\tif (isA && isB) input = sort(input, expect);\r\n\tif (isB) expect = stringify(expect);\r\n\tif (isA) input = stringify(input);\r\n\r\n\tif (expect && typeof expect == 'object') {\r\n\t\tinput = stringify(sort(input, expect));\r\n\t\texpect = stringify(expect);\r\n\t}\r\n\r\n\tisA = typeof input == 'string';\r\n\tisB = typeof expect == 'string';\r\n\r\n\tif (isA && /\\r?\\n/.test(input)) return lines(input, ''+expect);\r\n\tif (isB && /\\r?\\n/.test(expect)) return lines(''+input, expect);\r\n\tif (isA && isB) return chars(input, expect);\r\n\r\n\treturn direct(input, expect);\r\n}\r\n", "import { dequal } from 'dequal';\r\nimport { compare, lines } from 'uvu/diff';\r\n\r\nfunction dedent(str) {\r\n\tstr = str.replace(/\\r?\\n/g, '\\n');\r\n  let arr = str.match(/^[ \\t]*(?=\\S)/gm);\r\n  let i = 0, min = 1/0, len = (arr||[]).length;\r\n  for (; i < len; i++) min = Math.min(min, arr[i].length);\r\n  return len && min ? str.replace(new RegExp(`^[ \\\\t]{${min}}`, 'gm'), '') : str;\r\n}\r\n\r\nexport class Assertion extends Error {\r\n\tconstructor(opts={}) {\r\n\t\tsuper(opts.message);\r\n\t\tthis.name = 'Assertion';\r\n\t\tthis.code = 'ERR_ASSERTION';\r\n\t\tif (Error.captureStackTrace) {\r\n\t\t\tError.captureStackTrace(this, this.constructor);\r\n\t\t}\r\n\t\tthis.details = opts.details || false;\r\n\t\tthis.generated = !!opts.generated;\r\n\t\tthis.operator = opts.operator;\r\n\t\tthis.expects = opts.expects;\r\n\t\tthis.actual = opts.actual;\r\n\t}\r\n}\r\n\r\nfunction assert(bool, actual, expects, operator, detailer, backup, msg) {\r\n\tif (bool) return;\r\n\tlet message = msg || backup;\r\n\tif (msg instanceof Error) throw msg;\r\n\tlet details = detailer && detailer(actual, expects);\r\n\tthrow new Assertion({ actual, expects, operator, message, details, generated: !msg });\r\n}\r\n\r\nexport function ok(val, msg) {\r\n\tassert(!!val, false, true, 'ok', false, 'Expected value to be truthy', msg);\r\n}\r\n\r\nexport function is(val, exp, msg) {\r\n\tassert(val === exp, val, exp, 'is', compare, 'Expected values to be strictly equal:', msg);\r\n}\r\n\r\nexport function equal(val, exp, msg) {\r\n\tassert(dequal(val, exp), val, exp, 'equal', compare, 'Expected values to be deeply equal:', msg);\r\n}\r\n\r\nexport function unreachable(msg) {\r\n\tassert(false, true, false, 'unreachable', false, 'Expected not to be reached!', msg);\r\n}\r\n\r\nexport function type(val, exp, msg) {\r\n\tlet tmp = typeof val;\r\n\tassert(tmp === exp, tmp, exp, 'type', false, `Expected \"${tmp}\" to be \"${exp}\"`, msg);\r\n}\r\n\r\nexport function instance(val, exp, msg) {\r\n\tlet name = '`' + (exp.name || exp.constructor.name) + '`';\r\n\tassert(val instanceof exp, val, exp, 'instance', false, `Expected value to be an instance of ${name}`, msg);\r\n}\r\n\r\nexport function match(val, exp, msg) {\r\n\tif (typeof exp === 'string') {\r\n\t\tassert(val.includes(exp), val, exp, 'match', false, `Expected value to include \"${exp}\" substring`, msg);\r\n\t} else {\r\n\t\tassert(exp.test(val), val, exp, 'match', false, `Expected value to match \\`${String(exp)}\\` pattern`, msg);\r\n\t}\r\n}\r\n\r\nexport function snapshot(val, exp, msg) {\r\n\tval=dedent(val); exp=dedent(exp);\r\n\tassert(val === exp, val, exp, 'snapshot', lines, 'Expected value to match snapshot:', msg);\r\n}\r\n\r\nconst lineNums = (x, y) => lines(x, y, 1);\r\nexport function fixture(val, exp, msg) {\r\n\tval=dedent(val); exp=dedent(exp);\r\n\tassert(val === exp, val, exp, 'fixture', lineNums, 'Expected value to match fixture:', msg);\r\n}\r\n\r\nexport function throws(blk, exp, msg) {\r\n\tif (!msg && typeof exp === 'string') {\r\n\t\tmsg = exp; exp = null;\r\n\t}\r\n\r\n\ttry {\r\n\t\tblk();\r\n\t\tassert(false, false, true, 'throws', false, 'Expected function to throw', msg);\r\n\t} catch (err) {\r\n\t\tif (err instanceof Assertion) throw err;\r\n\r\n\t\tif (typeof exp === 'function') {\r\n\t\t\tassert(exp(err), false, true, 'throws', false, 'Expected function to throw matching exception', msg);\r\n\t\t} else if (exp instanceof RegExp) {\r\n\t\t\tassert(exp.test(err.message), false, true, 'throws', false, `Expected function to throw exception matching \\`${String(exp)}\\` pattern`, msg);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// ---\r\n\r\nexport function not(val, msg) {\r\n\tassert(!val, true, false, 'not', false, 'Expected value to be falsey', msg);\r\n}\r\n\r\nnot.ok = not;\r\n\r\nis.not = function (val, exp, msg) {\r\n\tassert(val !== exp, val, exp, 'is.not', false, 'Expected values not to be strictly equal', msg);\r\n}\r\n\r\nnot.equal = function (val, exp, msg) {\r\n\tassert(!dequal(val, exp), val, exp, 'not.equal', false, 'Expected values not to be deeply equal', msg);\r\n}\r\n\r\nnot.type = function (val, exp, msg) {\r\n\tlet tmp = typeof val;\r\n\tassert(tmp !== exp, tmp, exp, 'not.type', false, `Expected \"${tmp}\" not to be \"${exp}\"`, msg);\r\n}\r\n\r\nnot.instance = function (val, exp, msg) {\r\n\tlet name = '`' + (exp.name || exp.constructor.name) + '`';\r\n\tassert(!(val instanceof exp), val, exp, 'not.instance', false, `Expected value not to be an instance of ${name}`, msg);\r\n}\r\n\r\nnot.snapshot = function (val, exp, msg) {\r\n\tval=dedent(val); exp=dedent(exp);\r\n\tassert(val !== exp, val, exp, 'not.snapshot', false, 'Expected value not to match snapshot', msg);\r\n}\r\n\r\nnot.fixture = function (val, exp, msg) {\r\n\tval=dedent(val); exp=dedent(exp);\r\n\tassert(val !== exp, val, exp, 'not.fixture', false, 'Expected value not to match fixture', msg);\r\n}\r\n\r\nnot.match = function (val, exp, msg) {\r\n\tif (typeof exp === 'string') {\r\n\t\tassert(!val.includes(exp), val, exp, 'not.match', false, `Expected value not to include \"${exp}\" substring`, msg);\r\n\t} else {\r\n\t\tassert(!exp.test(val), val, exp, 'not.match', false, `Expected value not to match \\`${String(exp)}\\` pattern`, msg);\r\n\t}\r\n}\r\n\r\nnot.throws = function (blk, exp, msg) {\r\n\tif (!msg && typeof exp === 'string') {\r\n\t\tmsg = exp; exp = null;\r\n\t}\r\n\r\n\ttry {\r\n\t\tblk();\r\n\t} catch (err) {\r\n\t\tif (typeof exp === 'function') {\r\n\t\t\tassert(!exp(err), true, false, 'not.throws', false, 'Expected function not to throw matching exception', msg);\r\n\t\t} else if (exp instanceof RegExp) {\r\n\t\t\tassert(!exp.test(err.message), true, false, 'not.throws', false, `Expected function not to throw exception matching \\`${String(exp)}\\` pattern`, msg);\r\n\t\t} else if (!exp) {\r\n\t\t\tassert(false, true, false, 'not.throws', false, 'Expected function not to throw', msg);\r\n\t\t}\r\n\t}\r\n}\r\n", "/**\r\n * Character codes.\r\n *\r\n * This module is compiled away!\r\n *\r\n * micromark works based on character codes.\r\n * This module contains constants for the ASCII block and the replacement\r\n * character.\r\n * A couple of them are handled in a special way, such as the line endings\r\n * (CR, LF, and CR+LF, commonly known as end-of-line: EOLs), the tab (horizontal\r\n * tab) and its expansion based on what column it’s at (virtual space),\r\n * and the end-of-file (eof) character.\r\n * As values are preprocessed before handling them, the actual characters LF,\r\n * CR, HT, and NUL (which is present as the replacement character), are\r\n * guaranteed to not exist.\r\n *\r\n * Unicode basic latin block.\r\n */\r\nexport const codes = {\r\n  carriageReturn: -5,\r\n  lineFeed: -4,\r\n  carriageReturnLineFeed: -3,\r\n  horizontalTab: -2,\r\n  virtualSpace: -1,\r\n  eof: null,\r\n  nul: 0,\r\n  soh: 1,\r\n  stx: 2,\r\n  etx: 3,\r\n  eot: 4,\r\n  enq: 5,\r\n  ack: 6,\r\n  bel: 7,\r\n  bs: 8,\r\n  ht: 9, // `\\t`\r\n  lf: 10, // `\\n`\r\n  vt: 11, // `\\v`\r\n  ff: 12, // `\\f`\r\n  cr: 13, // `\\r`\r\n  so: 14,\r\n  si: 15,\r\n  dle: 16,\r\n  dc1: 17,\r\n  dc2: 18,\r\n  dc3: 19,\r\n  dc4: 20,\r\n  nak: 21,\r\n  syn: 22,\r\n  etb: 23,\r\n  can: 24,\r\n  em: 25,\r\n  sub: 26,\r\n  esc: 27,\r\n  fs: 28,\r\n  gs: 29,\r\n  rs: 30,\r\n  us: 31,\r\n  space: 32,\r\n  exclamationMark: 33, // `!`\r\n  quotationMark: 34, // `\"`\r\n  numberSign: 35, // `#`\r\n  dollarSign: 36, // `$`\r\n  percentSign: 37, // `%`\r\n  ampersand: 38, // `&`\r\n  apostrophe: 39, // `'`\r\n  leftParenthesis: 40, // `(`\r\n  rightParenthesis: 41, // `)`\r\n  asterisk: 42, // `*`\r\n  plusSign: 43, // `+`\r\n  comma: 44, // `,`\r\n  dash: 45, // `-`\r\n  dot: 46, // `.`\r\n  slash: 47, // `/`\r\n  digit0: 48, // `0`\r\n  digit1: 49, // `1`\r\n  digit2: 50, // `2`\r\n  digit3: 51, // `3`\r\n  digit4: 52, // `4`\r\n  digit5: 53, // `5`\r\n  digit6: 54, // `6`\r\n  digit7: 55, // `7`\r\n  digit8: 56, // `8`\r\n  digit9: 57, // `9`\r\n  colon: 58, // `:`\r\n  semicolon: 59, // `;`\r\n  lessThan: 60, // `<`\r\n  equalsTo: 61, // `=`\r\n  greaterThan: 62, // `>`\r\n  questionMark: 63, // `?`\r\n  atSign: 64, // `@`\r\n  uppercaseA: 65, // `A`\r\n  uppercaseB: 66, // `B`\r\n  uppercaseC: 67, // `C`\r\n  uppercaseD: 68, // `D`\r\n  uppercaseE: 69, // `E`\r\n  uppercaseF: 70, // `F`\r\n  uppercaseG: 71, // `G`\r\n  uppercaseH: 72, // `H`\r\n  uppercaseI: 73, // `I`\r\n  uppercaseJ: 74, // `J`\r\n  uppercaseK: 75, // `K`\r\n  uppercaseL: 76, // `L`\r\n  uppercaseM: 77, // `M`\r\n  uppercaseN: 78, // `N`\r\n  uppercaseO: 79, // `O`\r\n  uppercaseP: 80, // `P`\r\n  uppercaseQ: 81, // `Q`\r\n  uppercaseR: 82, // `R`\r\n  uppercaseS: 83, // `S`\r\n  uppercaseT: 84, // `T`\r\n  uppercaseU: 85, // `U`\r\n  uppercaseV: 86, // `V`\r\n  uppercaseW: 87, // `W`\r\n  uppercaseX: 88, // `X`\r\n  uppercaseY: 89, // `Y`\r\n  uppercaseZ: 90, // `Z`\r\n  leftSquareBracket: 91, // `[`\r\n  backslash: 92, // `\\`\r\n  rightSquareBracket: 93, // `]`\r\n  caret: 94, // `^`\r\n  underscore: 95, // `_`\r\n  graveAccent: 96, // `` ` ``\r\n  lowercaseA: 97, // `a`\r\n  lowercaseB: 98, // `b`\r\n  lowercaseC: 99, // `c`\r\n  lowercaseD: 100, // `d`\r\n  lowercaseE: 101, // `e`\r\n  lowercaseF: 102, // `f`\r\n  lowercaseG: 103, // `g`\r\n  lowercaseH: 104, // `h`\r\n  lowercaseI: 105, // `i`\r\n  lowercaseJ: 106, // `j`\r\n  lowercaseK: 107, // `k`\r\n  lowercaseL: 108, // `l`\r\n  lowercaseM: 109, // `m`\r\n  lowercaseN: 110, // `n`\r\n  lowercaseO: 111, // `o`\r\n  lowercaseP: 112, // `p`\r\n  lowercaseQ: 113, // `q`\r\n  lowercaseR: 114, // `r`\r\n  lowercaseS: 115, // `s`\r\n  lowercaseT: 116, // `t`\r\n  lowercaseU: 117, // `u`\r\n  lowercaseV: 118, // `v`\r\n  lowercaseW: 119, // `w`\r\n  lowercaseX: 120, // `x`\r\n  lowercaseY: 121, // `y`\r\n  lowercaseZ: 122, // `z`\r\n  leftCurlyBrace: 123, // `{`\r\n  verticalBar: 124, // `|`\r\n  rightCurlyBrace: 125, // `}`\r\n  tilde: 126, // `~`\r\n  del: 127,\r\n  // Unicode Specials block.\r\n  byteOrderMarker: 65279,\r\n  // Unicode Specials block.\r\n  replacementCharacter: 65533 // `�`\r\n}\r\n", "// This module is generated by `script/`.\r\n//\r\n// CommonMark handles attention (emphasis, strong) markers based on what comes\r\n// before or after them.\r\n// One such difference is if those characters are Unicode punctuation.\r\n// This script is generated from the Unicode data.\r\nexport const unicodePunctuationRegex =\r\n  /[!-/:-@[-`{-~\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061D-\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C77\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1B7D\\u1B7E\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4F\\u2E52-\\u2E5D\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\r\n", "/**\r\n * @typedef {import('micromark-util-types').Code} Code\r\n */\r\n\r\nimport {codes} from 'micromark-util-symbol/codes.js'\r\nimport {unicodePunctuationRegex} from './lib/unicode-punctuation-regex.js'\r\n\r\n/**\r\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\r\n * case insensitive).\r\n *\r\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\r\n *\r\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\r\n * to U+005A (`Z`).\r\n *\r\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\r\n * to U+007A (`z`).\r\n */\r\nexport const asciiAlpha = regexCheck(/[A-Za-z]/)\r\n\r\n/**\r\n * Check whether the character code represents an ASCII digit (`0` through `9`).\r\n *\r\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\r\n * U+0039 (`9`).\r\n */\r\nexport const asciiDigit = regexCheck(/\\d/)\r\n\r\n/**\r\n * Check whether the character code represents an ASCII hex digit (`a` through\r\n * `f`, case insensitive, or `0` through `9`).\r\n *\r\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\r\n * digit, or an ASCII lower hex digit.\r\n *\r\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\r\n * (`A`) to U+0046 (`F`).\r\n *\r\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\r\n * (`a`) to U+0066 (`f`).\r\n */\r\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/)\r\n\r\n/**\r\n * Check whether the character code represents an ASCII alphanumeric (`a`\r\n * through `z`, case insensitive, or `0` through `9`).\r\n *\r\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\r\n * (see `asciiAlpha`).\r\n */\r\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/)\r\n\r\n/**\r\n * Check whether the character code represents ASCII punctuation.\r\n *\r\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\r\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\r\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\r\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\r\n */\r\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/)\r\n\r\n/**\r\n * Check whether the character code represents an ASCII atext.\r\n *\r\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\r\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\r\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\r\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\r\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\r\n * (`{`) to U+007E TILDE (`~`).\r\n *\r\n * See:\r\n * **\\[RFC5322]**:\r\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\r\n * P. Resnick.\r\n * IETF.\r\n */\r\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/)\r\n\r\n/**\r\n * Check whether a character code is an ASCII control character.\r\n *\r\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\r\n * to U+001F (US), or U+007F (DEL).\r\n *\r\n * @param {Code} code\r\n * @returns {code is number}\r\n */\r\nexport function asciiControl(code) {\r\n  return (\r\n    // Special whitespace codes (which have negative values), C0 and Control\r\n    // character DEL\r\n    code !== null && (code < codes.space || code === codes.del)\r\n  )\r\n}\r\n\r\n/**\r\n * Check whether a character code is a markdown line ending (see\r\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\r\n *\r\n * @param {Code} code\r\n * @returns {code is number}\r\n */\r\nexport function markdownLineEndingOrSpace(code) {\r\n  return code !== null && (code < codes.nul || code === codes.space)\r\n}\r\n\r\n/**\r\n * Check whether a character code is a markdown line ending.\r\n *\r\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\r\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\r\n *\r\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\r\n * RETURN (CR) are replaced by these virtual characters depending on whether\r\n * they occurred together.\r\n *\r\n * @param {Code} code\r\n * @returns {code is number}\r\n */\r\nexport function markdownLineEnding(code) {\r\n  return code !== null && code < codes.horizontalTab\r\n}\r\n\r\n/**\r\n * Check whether a character code is a markdown space.\r\n *\r\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\r\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\r\n *\r\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\r\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\r\n * SPACE (VS) characters, depending on the column at which the tab occurred.\r\n *\r\n * @param {Code} code\r\n * @returns {code is number}\r\n */\r\nexport function markdownSpace(code) {\r\n  return (\r\n    code === codes.horizontalTab ||\r\n    code === codes.virtualSpace ||\r\n    code === codes.space\r\n  )\r\n}\r\n\r\n/**\r\n * Check whether the character code represents Unicode whitespace.\r\n *\r\n * Note that this does handle micromark specific markdown whitespace characters.\r\n * See `markdownLineEndingOrSpace` to check that.\r\n *\r\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\r\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\r\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\r\n *\r\n * See:\r\n * **\\[UNICODE]**:\r\n * [The Unicode Standard](https://www.unicode.org/versions/).\r\n * Unicode Consortium.\r\n */\r\nexport const unicodeWhitespace = regexCheck(/\\s/)\r\n\r\n/**\r\n * Check whether the character code represents Unicode punctuation.\r\n *\r\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\r\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\r\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\r\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\r\n * punctuation (see `asciiPunctuation`).\r\n *\r\n * See:\r\n * **\\[UNICODE]**:\r\n * [The Unicode Standard](https://www.unicode.org/versions/).\r\n * Unicode Consortium.\r\n */\r\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\r\n// In fact adds to the bundle size.\r\nexport const unicodePunctuation = regexCheck(unicodePunctuationRegex)\r\n\r\n/**\r\n * Create a code check from a regex.\r\n *\r\n * @param {RegExp} regex\r\n * @returns {(code: Code) => code is number}\r\n */\r\nfunction regexCheck(regex) {\r\n  return check\r\n\r\n  /**\r\n   * Check whether a code matches the bound regex.\r\n   *\r\n   * @param {Code} code Character code\r\n   * @returns {code is number} Whether the character code matches the bound regex\r\n   */\r\n  function check(code) {\r\n    return code !== null && regex.test(String.fromCharCode(code))\r\n  }\r\n}\r\n", "/**\r\n * @typedef {import('micromark-util-types').Effects} Effects\r\n * @typedef {import('micromark-util-types').State} State\r\n */\r\n\r\nimport {markdownSpace} from 'micromark-util-character'\r\n\r\n/**\r\n * @param {Effects} effects\r\n * @param {State} ok\r\n * @param {string} type\r\n * @param {number} [max=Infinity]\r\n * @returns {State}\r\n */\r\nexport function factorySpace(effects, ok, type, max) {\r\n  const limit = max ? max - 1 : Number.POSITIVE_INFINITY\r\n  let size = 0\r\n\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    if (markdownSpace(code)) {\r\n      effects.enter(type)\r\n      return prefix(code)\r\n    }\r\n\r\n    return ok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function prefix(code) {\r\n    if (markdownSpace(code) && size++ < limit) {\r\n      effects.consume(code)\r\n      return prefix\r\n    }\r\n\r\n    effects.exit(type)\r\n    return ok(code)\r\n  }\r\n}\r\n", "/**\r\n * This module is compiled away!\r\n *\r\n * Here is the list of all types of tokens exposed by micromark, with a short\r\n * explanation of what they include and where they are found.\r\n * In picking names, generally, the rule is to be as explicit as possible\r\n * instead of reusing names.\r\n * For example, there is a `definitionDestination` and a `resourceDestination`,\r\n * instead of one shared name.\r\n */\r\n\r\nexport const types = {\r\n  // Generic type for data, such as in a title, a destination, etc.\r\n  data: 'data',\r\n\r\n  // Generic type for syntactic whitespace (tabs, virtual spaces, spaces).\r\n  // Such as, between a fenced code fence and an info string.\r\n  whitespace: 'whitespace',\r\n\r\n  // Generic type for line endings (line feed, carriage return, carriage return +\r\n  // line feed).\r\n  lineEnding: 'lineEnding',\r\n\r\n  // A line ending, but ending a blank line.\r\n  lineEndingBlank: 'lineEndingBlank',\r\n\r\n  // Generic type for whitespace (tabs, virtual spaces, spaces) at the start of a\r\n  // line.\r\n  linePrefix: 'linePrefix',\r\n\r\n  // Generic type for whitespace (tabs, virtual spaces, spaces) at the end of a\r\n  // line.\r\n  lineSuffix: 'lineSuffix',\r\n\r\n  // Whole ATX heading:\r\n  //\r\n  // ```markdown\r\n  // #\r\n  // ## Alpha\r\n  // ### Bravo ###\r\n  // ```\r\n  //\r\n  // Includes `atxHeadingSequence`, `whitespace`, `atxHeadingText`.\r\n  atxHeading: 'atxHeading',\r\n\r\n  // Sequence of number signs in an ATX heading (`###`).\r\n  atxHeadingSequence: 'atxHeadingSequence',\r\n\r\n  // Content in an ATX heading (`alpha`).\r\n  // Includes text.\r\n  atxHeadingText: 'atxHeadingText',\r\n\r\n  // Whole autolink (`<https://example.com>` or `<admin@example.com>`)\r\n  // Includes `autolinkMarker` and `autolinkProtocol` or `autolinkEmail`.\r\n  autolink: 'autolink',\r\n\r\n  // Email autolink w/o markers (`admin@example.com`)\r\n  autolinkEmail: 'autolinkEmail',\r\n\r\n  // Marker around an `autolinkProtocol` or `autolinkEmail` (`<` or `>`).\r\n  autolinkMarker: 'autolinkMarker',\r\n\r\n  // Protocol autolink w/o markers (`https://example.com`)\r\n  autolinkProtocol: 'autolinkProtocol',\r\n\r\n  // A whole character escape (`\\-`).\r\n  // Includes `escapeMarker` and `characterEscapeValue`.\r\n  characterEscape: 'characterEscape',\r\n\r\n  // The escaped character (`-`).\r\n  characterEscapeValue: 'characterEscapeValue',\r\n\r\n  // A whole character reference (`&amp;`, `&#8800;`, or `&#x1D306;`).\r\n  // Includes `characterReferenceMarker`, an optional\r\n  // `characterReferenceMarkerNumeric`, in which case an optional\r\n  // `characterReferenceMarkerHexadecimal`, and a `characterReferenceValue`.\r\n  characterReference: 'characterReference',\r\n\r\n  // The start or end marker (`&` or `;`).\r\n  characterReferenceMarker: 'characterReferenceMarker',\r\n\r\n  // Mark reference as numeric (`#`).\r\n  characterReferenceMarkerNumeric: 'characterReferenceMarkerNumeric',\r\n\r\n  // Mark reference as numeric (`x` or `X`).\r\n  characterReferenceMarkerHexadecimal: 'characterReferenceMarkerHexadecimal',\r\n\r\n  // Value of character reference w/o markers (`amp`, `8800`, or `1D306`).\r\n  characterReferenceValue: 'characterReferenceValue',\r\n\r\n  // Whole fenced code:\r\n  //\r\n  // ````markdown\r\n  // ```js\r\n  // alert(1)\r\n  // ```\r\n  // ````\r\n  codeFenced: 'codeFenced',\r\n\r\n  // A fenced code fence, including whitespace, sequence, info, and meta\r\n  // (` ```js `).\r\n  codeFencedFence: 'codeFencedFence',\r\n\r\n  // Sequence of grave accent or tilde characters (` ``` `) in a fence.\r\n  codeFencedFenceSequence: 'codeFencedFenceSequence',\r\n\r\n  // Info word (`js`) in a fence.\r\n  // Includes string.\r\n  codeFencedFenceInfo: 'codeFencedFenceInfo',\r\n\r\n  // Meta words (`highlight=\"1\"`) in a fence.\r\n  // Includes string.\r\n  codeFencedFenceMeta: 'codeFencedFenceMeta',\r\n\r\n  // A line of code.\r\n  codeFlowValue: 'codeFlowValue',\r\n\r\n  // Whole indented code:\r\n  //\r\n  // ```markdown\r\n  //     alert(1)\r\n  // ```\r\n  //\r\n  // Includes `lineEnding`, `linePrefix`, and `codeFlowValue`.\r\n  codeIndented: 'codeIndented',\r\n\r\n  // A text code (``` `alpha` ```).\r\n  // Includes `codeTextSequence`, `codeTextData`, `lineEnding`, and can include\r\n  // `codeTextPadding`.\r\n  codeText: 'codeText',\r\n\r\n  codeTextData: 'codeTextData',\r\n\r\n  // A space or line ending right after or before a tick.\r\n  codeTextPadding: 'codeTextPadding',\r\n\r\n  // A text code fence (` `` `).\r\n  codeTextSequence: 'codeTextSequence',\r\n\r\n  // Whole content:\r\n  //\r\n  // ```markdown\r\n  // [a]: b\r\n  // c\r\n  // =\r\n  // d\r\n  // ```\r\n  //\r\n  // Includes `paragraph` and `definition`.\r\n  content: 'content',\r\n  // Whole definition:\r\n  //\r\n  // ```markdown\r\n  // [micromark]: https://github.com/micromark/micromark\r\n  // ```\r\n  //\r\n  // Includes `definitionLabel`, `definitionMarker`, `whitespace`,\r\n  // `definitionDestination`, and optionally `lineEnding` and `definitionTitle`.\r\n  definition: 'definition',\r\n\r\n  // Destination of a definition (`https://github.com/micromark/micromark` or\r\n  // `<https://github.com/micromark/micromark>`).\r\n  // Includes `definitionDestinationLiteral` or `definitionDestinationRaw`.\r\n  definitionDestination: 'definitionDestination',\r\n\r\n  // Enclosed destination of a definition\r\n  // (`<https://github.com/micromark/micromark>`).\r\n  // Includes `definitionDestinationLiteralMarker` and optionally\r\n  // `definitionDestinationString`.\r\n  definitionDestinationLiteral: 'definitionDestinationLiteral',\r\n\r\n  // Markers of an enclosed definition destination (`<` or `>`).\r\n  definitionDestinationLiteralMarker: 'definitionDestinationLiteralMarker',\r\n\r\n  // Unenclosed destination of a definition\r\n  // (`https://github.com/micromark/micromark`).\r\n  // Includes `definitionDestinationString`.\r\n  definitionDestinationRaw: 'definitionDestinationRaw',\r\n\r\n  // Text in an destination (`https://github.com/micromark/micromark`).\r\n  // Includes string.\r\n  definitionDestinationString: 'definitionDestinationString',\r\n\r\n  // Label of a definition (`[micromark]`).\r\n  // Includes `definitionLabelMarker` and `definitionLabelString`.\r\n  definitionLabel: 'definitionLabel',\r\n\r\n  // Markers of a definition label (`[` or `]`).\r\n  definitionLabelMarker: 'definitionLabelMarker',\r\n\r\n  // Value of a definition label (`micromark`).\r\n  // Includes string.\r\n  definitionLabelString: 'definitionLabelString',\r\n\r\n  // Marker between a label and a destination (`:`).\r\n  definitionMarker: 'definitionMarker',\r\n\r\n  // Title of a definition (`\"x\"`, `'y'`, or `(z)`).\r\n  // Includes `definitionTitleMarker` and optionally `definitionTitleString`.\r\n  definitionTitle: 'definitionTitle',\r\n\r\n  // Marker around a title of a definition (`\"`, `'`, `(`, or `)`).\r\n  definitionTitleMarker: 'definitionTitleMarker',\r\n\r\n  // Data without markers in a title (`z`).\r\n  // Includes string.\r\n  definitionTitleString: 'definitionTitleString',\r\n\r\n  // Emphasis (`*alpha*`).\r\n  // Includes `emphasisSequence` and `emphasisText`.\r\n  emphasis: 'emphasis',\r\n\r\n  // Sequence of emphasis markers (`*` or `_`).\r\n  emphasisSequence: 'emphasisSequence',\r\n\r\n  // Emphasis text (`alpha`).\r\n  // Includes text.\r\n  emphasisText: 'emphasisText',\r\n\r\n  // The character escape marker (`\\`).\r\n  escapeMarker: 'escapeMarker',\r\n\r\n  // A hard break created with a backslash (`\\\\n`).\r\n  // Includes `escapeMarker` (does not include the line ending)\r\n  hardBreakEscape: 'hardBreakEscape',\r\n\r\n  // A hard break created with trailing spaces (`  \\n`).\r\n  // Does not include the line ending.\r\n  hardBreakTrailing: 'hardBreakTrailing',\r\n\r\n  // Flow HTML:\r\n  //\r\n  // ```markdown\r\n  // <div\r\n  // ```\r\n  //\r\n  // Inlcudes `lineEnding`, `htmlFlowData`.\r\n  htmlFlow: 'htmlFlow',\r\n\r\n  htmlFlowData: 'htmlFlowData',\r\n\r\n  // HTML in text (the tag in `a <i> b`).\r\n  // Includes `lineEnding`, `htmlTextData`.\r\n  htmlText: 'htmlText',\r\n\r\n  htmlTextData: 'htmlTextData',\r\n\r\n  // Whole image (`![alpha](bravo)`, `![alpha][bravo]`, `![alpha][]`, or\r\n  // `![alpha]`).\r\n  // Includes `label` and an optional `resource` or `reference`.\r\n  image: 'image',\r\n\r\n  // Whole link label (`[*alpha*]`).\r\n  // Includes `labelLink` or `labelImage`, `labelText`, and `labelEnd`.\r\n  label: 'label',\r\n\r\n  // Text in an label (`*alpha*`).\r\n  // Includes text.\r\n  labelText: 'labelText',\r\n\r\n  // Start a link label (`[`).\r\n  // Includes a `labelMarker`.\r\n  labelLink: 'labelLink',\r\n\r\n  // Start an image label (`![`).\r\n  // Includes `labelImageMarker` and `labelMarker`.\r\n  labelImage: 'labelImage',\r\n\r\n  // Marker of a label (`[` or `]`).\r\n  labelMarker: 'labelMarker',\r\n\r\n  // Marker to start an image (`!`).\r\n  labelImageMarker: 'labelImageMarker',\r\n\r\n  // End a label (`]`).\r\n  // Includes `labelMarker`.\r\n  labelEnd: 'labelEnd',\r\n\r\n  // Whole link (`[alpha](bravo)`, `[alpha][bravo]`, `[alpha][]`, or `[alpha]`).\r\n  // Includes `label` and an optional `resource` or `reference`.\r\n  link: 'link',\r\n\r\n  // Whole paragraph:\r\n  //\r\n  // ```markdown\r\n  // alpha\r\n  // bravo.\r\n  // ```\r\n  //\r\n  // Includes text.\r\n  paragraph: 'paragraph',\r\n\r\n  // A reference (`[alpha]` or `[]`).\r\n  // Includes `referenceMarker` and an optional `referenceString`.\r\n  reference: 'reference',\r\n\r\n  // A reference marker (`[` or `]`).\r\n  referenceMarker: 'referenceMarker',\r\n\r\n  // Reference text (`alpha`).\r\n  // Includes string.\r\n  referenceString: 'referenceString',\r\n\r\n  // A resource (`(https://example.com \"alpha\")`).\r\n  // Includes `resourceMarker`, an optional `resourceDestination` with an optional\r\n  // `whitespace` and `resourceTitle`.\r\n  resource: 'resource',\r\n\r\n  // A resource destination (`https://example.com`).\r\n  // Includes `resourceDestinationLiteral` or `resourceDestinationRaw`.\r\n  resourceDestination: 'resourceDestination',\r\n\r\n  // A literal resource destination (`<https://example.com>`).\r\n  // Includes `resourceDestinationLiteralMarker` and optionally\r\n  // `resourceDestinationString`.\r\n  resourceDestinationLiteral: 'resourceDestinationLiteral',\r\n\r\n  // A resource destination marker (`<` or `>`).\r\n  resourceDestinationLiteralMarker: 'resourceDestinationLiteralMarker',\r\n\r\n  // A raw resource destination (`https://example.com`).\r\n  // Includes `resourceDestinationString`.\r\n  resourceDestinationRaw: 'resourceDestinationRaw',\r\n\r\n  // Resource destination text (`https://example.com`).\r\n  // Includes string.\r\n  resourceDestinationString: 'resourceDestinationString',\r\n\r\n  // A resource marker (`(` or `)`).\r\n  resourceMarker: 'resourceMarker',\r\n\r\n  // A resource title (`\"alpha\"`, `'alpha'`, or `(alpha)`).\r\n  // Includes `resourceTitleMarker` and optionally `resourceTitleString`.\r\n  resourceTitle: 'resourceTitle',\r\n\r\n  // A resource title marker (`\"`, `'`, `(`, or `)`).\r\n  resourceTitleMarker: 'resourceTitleMarker',\r\n\r\n  // Resource destination title (`alpha`).\r\n  // Includes string.\r\n  resourceTitleString: 'resourceTitleString',\r\n\r\n  // Whole setext heading:\r\n  //\r\n  // ```markdown\r\n  // alpha\r\n  // bravo\r\n  // =====\r\n  // ```\r\n  //\r\n  // Includes `setextHeadingText`, `lineEnding`, `linePrefix`, and\r\n  // `setextHeadingLine`.\r\n  setextHeading: 'setextHeading',\r\n\r\n  // Content in a setext heading (`alpha\\nbravo`).\r\n  // Includes text.\r\n  setextHeadingText: 'setextHeadingText',\r\n\r\n  // Underline in a setext heading, including whitespace suffix (`==`).\r\n  // Includes `setextHeadingLineSequence`.\r\n  setextHeadingLine: 'setextHeadingLine',\r\n\r\n  // Sequence of equals or dash characters in underline in a setext heading (`-`).\r\n  setextHeadingLineSequence: 'setextHeadingLineSequence',\r\n\r\n  // Strong (`**alpha**`).\r\n  // Includes `strongSequence` and `strongText`.\r\n  strong: 'strong',\r\n\r\n  // Sequence of strong markers (`**` or `__`).\r\n  strongSequence: 'strongSequence',\r\n\r\n  // Strong text (`alpha`).\r\n  // Includes text.\r\n  strongText: 'strongText',\r\n\r\n  // Whole thematic break:\r\n  //\r\n  // ```markdown\r\n  // * * *\r\n  // ```\r\n  //\r\n  // Includes `thematicBreakSequence` and `whitespace`.\r\n  thematicBreak: 'thematicBreak',\r\n\r\n  // A sequence of one or more thematic break markers (`***`).\r\n  thematicBreakSequence: 'thematicBreakSequence',\r\n\r\n  // Whole block quote:\r\n  //\r\n  // ```markdown\r\n  // > a\r\n  // >\r\n  // > b\r\n  // ```\r\n  //\r\n  // Includes `blockQuotePrefix` and flow.\r\n  blockQuote: 'blockQuote',\r\n  // The `>` or `> ` of a block quote.\r\n  blockQuotePrefix: 'blockQuotePrefix',\r\n  // The `>` of a block quote prefix.\r\n  blockQuoteMarker: 'blockQuoteMarker',\r\n  // The optional ` ` of a block quote prefix.\r\n  blockQuotePrefixWhitespace: 'blockQuotePrefixWhitespace',\r\n\r\n  // Whole unordered list:\r\n  //\r\n  // ```markdown\r\n  // - a\r\n  //   b\r\n  // ```\r\n  //\r\n  // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further\r\n  // lines.\r\n  listOrdered: 'listOrdered',\r\n\r\n  // Whole ordered list:\r\n  //\r\n  // ```markdown\r\n  // 1. a\r\n  //    b\r\n  // ```\r\n  //\r\n  // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further\r\n  // lines.\r\n  listUnordered: 'listUnordered',\r\n\r\n  // The indent of further list item lines.\r\n  listItemIndent: 'listItemIndent',\r\n\r\n  // A marker, as in, `*`, `+`, `-`, `.`, or `)`.\r\n  listItemMarker: 'listItemMarker',\r\n\r\n  // The thing that starts a list item, such as `1. `.\r\n  // Includes `listItemValue` if ordered, `listItemMarker`, and\r\n  // `listItemPrefixWhitespace` (unless followed by a line ending).\r\n  listItemPrefix: 'listItemPrefix',\r\n\r\n  // The whitespace after a marker.\r\n  listItemPrefixWhitespace: 'listItemPrefixWhitespace',\r\n\r\n  // The numerical value of an ordered item.\r\n  listItemValue: 'listItemValue',\r\n\r\n  // Internal types used for subtokenizers, compiled away\r\n  chunkDocument: 'chunkDocument',\r\n  chunkContent: 'chunkContent',\r\n  chunkFlow: 'chunkFlow',\r\n  chunkText: 'chunkText',\r\n  chunkString: 'chunkString'\r\n}\r\n", "/**\r\n * @typedef {import('micromark-util-types').Code} Code\r\n */\r\n\r\nimport {\r\n  markdownLineEndingOrSpace,\r\n  unicodePunctuation,\r\n  unicodeWhitespace\r\n} from 'micromark-util-character'\r\nimport {codes} from 'micromark-util-symbol/codes.js'\r\nimport {constants} from 'micromark-util-symbol/constants.js'\r\n\r\n/**\r\n * Classify whether a character code represents whitespace, punctuation, or\r\n * something else.\r\n *\r\n * Used for attention (emphasis, strong), whose sequences can open or close\r\n * based on the class of surrounding characters.\r\n *\r\n * Note that eof (`null`) is seen as whitespace.\r\n *\r\n * @param {Code} code\r\n * @returns {number|undefined}\r\n */\r\nexport function classifyCharacter(code) {\r\n  if (\r\n    code === codes.eof ||\r\n    markdownLineEndingOrSpace(code) ||\r\n    unicodeWhitespace(code)\r\n  ) {\r\n    return constants.characterGroupWhitespace\r\n  }\r\n\r\n  if (unicodePunctuation(code)) {\r\n    return constants.characterGroupPunctuation\r\n  }\r\n}\r\n", "/**\r\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\r\n * @typedef {import('micromark-util-types').Event} Event\r\n * @typedef {import('micromark-util-types').Resolver} Resolver\r\n */\r\n\r\n/**\r\n * Call all `resolveAll`s.\r\n *\r\n * @param {{resolveAll?: Resolver}[]} constructs\r\n * @param {Event[]} events\r\n * @param {TokenizeContext} context\r\n * @returns {Event[]}\r\n */\r\nexport function resolveAll(constructs, events, context) {\r\n  /** @type {Resolver[]} */\r\n  const called = []\r\n  let index = -1\r\n\r\n  while (++index < constructs.length) {\r\n    const resolve = constructs[index].resolveAll\r\n\r\n    if (resolve && !called.includes(resolve)) {\r\n      events = resolve(events, context)\r\n      called.push(resolve)\r\n    }\r\n  }\r\n\r\n  return events\r\n}\r\n", "/**\r\n * @typedef {import('micromark-util-types').Construct} Construct\r\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\r\n * @typedef {import('micromark-util-types').State} State\r\n */\r\n\r\nimport {factorySpace} from 'micromark-factory-space'\r\nimport {markdownLineEnding} from 'micromark-util-character'\r\nimport {codes} from 'micromark-util-symbol/codes.js'\r\nimport {types} from 'micromark-util-symbol/types.js'\r\n\r\n/** @type {Construct} */\r\nexport const blankLine = {tokenize: tokenizeBlankLine, partial: true}\r\n\r\n/** @type {Tokenizer} */\r\nfunction tokenizeBlankLine(effects, ok, nok) {\r\n  return factorySpace(effects, afterWhitespace, types.linePrefix)\r\n\r\n  /** @type {State} */\r\n  function afterWhitespace(code) {\r\n    return code === codes.eof || markdownLineEnding(code) ? ok(code) : nok(code)\r\n  }\r\n}\r\n", "// This module is compiled away!\r\n//\r\n// While micromark works based on character codes, this module includes the\r\n// string versions of ’em.\r\n// The C0 block, except for LF, CR, HT, and w/ the replacement character added,\r\n// are available here.\r\nexport const values = {\r\n  ht: '\\t',\r\n  lf: '\\n',\r\n  cr: '\\r',\r\n  space: ' ',\r\n  exclamationMark: '!',\r\n  quotationMark: '\"',\r\n  numberSign: '#',\r\n  dollarSign: '$',\r\n  percentSign: '%',\r\n  ampersand: '&',\r\n  apostrophe: \"'\",\r\n  leftParenthesis: '(',\r\n  rightParenthesis: ')',\r\n  asterisk: '*',\r\n  plusSign: '+',\r\n  comma: ',',\r\n  dash: '-',\r\n  dot: '.',\r\n  slash: '/',\r\n  digit0: '0',\r\n  digit1: '1',\r\n  digit2: '2',\r\n  digit3: '3',\r\n  digit4: '4',\r\n  digit5: '5',\r\n  digit6: '6',\r\n  digit7: '7',\r\n  digit8: '8',\r\n  digit9: '9',\r\n  colon: ':',\r\n  semicolon: ';',\r\n  lessThan: '<',\r\n  equalsTo: '=',\r\n  greaterThan: '>',\r\n  questionMark: '?',\r\n  atSign: '@',\r\n  uppercaseA: 'A',\r\n  uppercaseB: 'B',\r\n  uppercaseC: 'C',\r\n  uppercaseD: 'D',\r\n  uppercaseE: 'E',\r\n  uppercaseF: 'F',\r\n  uppercaseG: 'G',\r\n  uppercaseH: 'H',\r\n  uppercaseI: 'I',\r\n  uppercaseJ: 'J',\r\n  uppercaseK: 'K',\r\n  uppercaseL: 'L',\r\n  uppercaseM: 'M',\r\n  uppercaseN: 'N',\r\n  uppercaseO: 'O',\r\n  uppercaseP: 'P',\r\n  uppercaseQ: 'Q',\r\n  uppercaseR: 'R',\r\n  uppercaseS: 'S',\r\n  uppercaseT: 'T',\r\n  uppercaseU: 'U',\r\n  uppercaseV: 'V',\r\n  uppercaseW: 'W',\r\n  uppercaseX: 'X',\r\n  uppercaseY: 'Y',\r\n  uppercaseZ: 'Z',\r\n  leftSquareBracket: '[',\r\n  backslash: '\\\\',\r\n  rightSquareBracket: ']',\r\n  caret: '^',\r\n  underscore: '_',\r\n  graveAccent: '`',\r\n  lowercaseA: 'a',\r\n  lowercaseB: 'b',\r\n  lowercaseC: 'c',\r\n  lowercaseD: 'd',\r\n  lowercaseE: 'e',\r\n  lowercaseF: 'f',\r\n  lowercaseG: 'g',\r\n  lowercaseH: 'h',\r\n  lowercaseI: 'i',\r\n  lowercaseJ: 'j',\r\n  lowercaseK: 'k',\r\n  lowercaseL: 'l',\r\n  lowercaseM: 'm',\r\n  lowercaseN: 'n',\r\n  lowercaseO: 'o',\r\n  lowercaseP: 'p',\r\n  lowercaseQ: 'q',\r\n  lowercaseR: 'r',\r\n  lowercaseS: 's',\r\n  lowercaseT: 't',\r\n  lowercaseU: 'u',\r\n  lowercaseV: 'v',\r\n  lowercaseW: 'w',\r\n  lowercaseX: 'x',\r\n  lowercaseY: 'y',\r\n  lowercaseZ: 'z',\r\n  leftCurlyBrace: '{',\r\n  verticalBar: '|',\r\n  rightCurlyBrace: '}',\r\n  tilde: '~',\r\n  replacementCharacter: '�'\r\n}\r\n", "import {values} from 'micromark-util-symbol/values.js'\r\n\r\n/**\r\n * Normalize an identifier (such as used in definitions).\r\n *\r\n * @param {string} value\r\n * @returns {string}\r\n */\r\nexport function normalizeIdentifier(value) {\r\n  return (\r\n    value\r\n      // Collapse Markdown whitespace.\r\n      .replace(/[\\t\\n\\r ]+/g, values.space)\r\n      // Trim.\r\n      .replace(/^ | $/g, '')\r\n      // Some characters are considered “uppercase”, but if their lowercase\r\n      // counterpart is uppercased will result in a different uppercase\r\n      // character.\r\n      // Hence, to get that form, we perform both lower- and uppercase.\r\n      // Upper case makes sure keys will not interact with default prototypal\r\n      // methods: no method is uppercase.\r\n      .toLowerCase()\r\n      .toUpperCase()\r\n  )\r\n}\r\n", "/**\r\n * @typedef {import('micromark-util-types').Construct} Construct\r\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\r\n * @typedef {import('micromark-util-types').Resolver} Resolver\r\n * @typedef {import('micromark-util-types').State} State\r\n * @typedef {import('micromark-util-types').Token} Token\r\n * @typedef {import('micromark-util-types').Event} Event\r\n * @typedef {import('micromark-util-types').Code} Code\r\n * @typedef {import('micromark-util-types').Point} Point\r\n */\r\n\r\nimport {ok as assert} from 'uvu/assert'\r\nimport {push, splice} from 'micromark-util-chunked'\r\nimport {classifyCharacter} from 'micromark-util-classify-character'\r\nimport {resolveAll} from 'micromark-util-resolve-all'\r\nimport {codes} from 'micromark-util-symbol/codes.js'\r\nimport {constants} from 'micromark-util-symbol/constants.js'\r\nimport {types} from 'micromark-util-symbol/types.js'\r\n\r\n/** @type {Construct} */\r\nexport const attention = {\r\n  name: 'attention',\r\n  tokenize: tokenizeAttention,\r\n  resolveAll: resolveAllAttention\r\n}\r\n\r\n/**\r\n * Take all events and resolve attention to emphasis or strong.\r\n *\r\n * @type {Resolver}\r\n */\r\nfunction resolveAllAttention(events, context) {\r\n  let index = -1\r\n  /** @type {number} */\r\n  let open\r\n  /** @type {Token} */\r\n  let group\r\n  /** @type {Token} */\r\n  let text\r\n  /** @type {Token} */\r\n  let openingSequence\r\n  /** @type {Token} */\r\n  let closingSequence\r\n  /** @type {number} */\r\n  let use\r\n  /** @type {Event[]} */\r\n  let nextEvents\r\n  /** @type {number} */\r\n  let offset\r\n\r\n  // Walk through all events.\r\n  //\r\n  // Note: performance of this is fine on an mb of normal markdown, but it’s\r\n  // a bottleneck for malicious stuff.\r\n  while (++index < events.length) {\r\n    // Find a token that can close.\r\n    if (\r\n      events[index][0] === 'enter' &&\r\n      events[index][1].type === 'attentionSequence' &&\r\n      events[index][1]._close\r\n    ) {\r\n      open = index\r\n\r\n      // Now walk back to find an opener.\r\n      while (open--) {\r\n        // Find a token that can open the closer.\r\n        if (\r\n          events[open][0] === 'exit' &&\r\n          events[open][1].type === 'attentionSequence' &&\r\n          events[open][1]._open &&\r\n          // If the markers are the same:\r\n          context.sliceSerialize(events[open][1]).charCodeAt(0) ===\r\n            context.sliceSerialize(events[index][1]).charCodeAt(0)\r\n        ) {\r\n          // If the opening can close or the closing can open,\r\n          // and the close size *is not* a multiple of three,\r\n          // but the sum of the opening and closing size *is* multiple of three,\r\n          // then don’t match.\r\n          if (\r\n            (events[open][1]._close || events[index][1]._open) &&\r\n            (events[index][1].end.offset - events[index][1].start.offset) % 3 &&\r\n            !(\r\n              (events[open][1].end.offset -\r\n                events[open][1].start.offset +\r\n                events[index][1].end.offset -\r\n                events[index][1].start.offset) %\r\n              3\r\n            )\r\n          ) {\r\n            continue\r\n          }\r\n\r\n          // Number of markers to use from the sequence.\r\n          use =\r\n            events[open][1].end.offset - events[open][1].start.offset > 1 &&\r\n            events[index][1].end.offset - events[index][1].start.offset > 1\r\n              ? 2\r\n              : 1\r\n\r\n          const start = Object.assign({}, events[open][1].end)\r\n          const end = Object.assign({}, events[index][1].start)\r\n          movePoint(start, -use)\r\n          movePoint(end, use)\r\n\r\n          openingSequence = {\r\n            type: use > 1 ? types.strongSequence : types.emphasisSequence,\r\n            start,\r\n            end: Object.assign({}, events[open][1].end)\r\n          }\r\n          closingSequence = {\r\n            type: use > 1 ? types.strongSequence : types.emphasisSequence,\r\n            start: Object.assign({}, events[index][1].start),\r\n            end\r\n          }\r\n          text = {\r\n            type: use > 1 ? types.strongText : types.emphasisText,\r\n            start: Object.assign({}, events[open][1].end),\r\n            end: Object.assign({}, events[index][1].start)\r\n          }\r\n          group = {\r\n            type: use > 1 ? types.strong : types.emphasis,\r\n            start: Object.assign({}, openingSequence.start),\r\n            end: Object.assign({}, closingSequence.end)\r\n          }\r\n\r\n          events[open][1].end = Object.assign({}, openingSequence.start)\r\n          events[index][1].start = Object.assign({}, closingSequence.end)\r\n\r\n          nextEvents = []\r\n\r\n          // If there are more markers in the opening, add them before.\r\n          if (events[open][1].end.offset - events[open][1].start.offset) {\r\n            nextEvents = push(nextEvents, [\r\n              ['enter', events[open][1], context],\r\n              ['exit', events[open][1], context]\r\n            ])\r\n          }\r\n\r\n          // Opening.\r\n          nextEvents = push(nextEvents, [\r\n            ['enter', group, context],\r\n            ['enter', openingSequence, context],\r\n            ['exit', openingSequence, context],\r\n            ['enter', text, context]\r\n          ])\r\n\r\n          // Between.\r\n          nextEvents = push(\r\n            nextEvents,\r\n            resolveAll(\r\n              context.parser.constructs.insideSpan.null,\r\n              events.slice(open + 1, index),\r\n              context\r\n            )\r\n          )\r\n\r\n          // Closing.\r\n          nextEvents = push(nextEvents, [\r\n            ['exit', text, context],\r\n            ['enter', closingSequence, context],\r\n            ['exit', closingSequence, context],\r\n            ['exit', group, context]\r\n          ])\r\n\r\n          // If there are more markers in the closing, add them after.\r\n          if (events[index][1].end.offset - events[index][1].start.offset) {\r\n            offset = 2\r\n            nextEvents = push(nextEvents, [\r\n              ['enter', events[index][1], context],\r\n              ['exit', events[index][1], context]\r\n            ])\r\n          } else {\r\n            offset = 0\r\n          }\r\n\r\n          splice(events, open - 1, index - open + 3, nextEvents)\r\n\r\n          index = open + nextEvents.length - offset - 2\r\n          break\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Remove remaining sequences.\r\n  index = -1\r\n\r\n  while (++index < events.length) {\r\n    if (events[index][1].type === 'attentionSequence') {\r\n      events[index][1].type = 'data'\r\n    }\r\n  }\r\n\r\n  return events\r\n}\r\n\r\n/** @type {Tokenizer} */\r\nfunction tokenizeAttention(effects, ok) {\r\n  const attentionMarkers = this.parser.constructs.attentionMarkers.null\r\n  const previous = this.previous\r\n  const before = classifyCharacter(previous)\r\n\r\n  /** @type {NonNullable<Code>} */\r\n  let marker\r\n\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    assert(\r\n      code === codes.asterisk || code === codes.underscore,\r\n      'expected asterisk or underscore'\r\n    )\r\n    effects.enter('attentionSequence')\r\n    marker = code\r\n    return sequence(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function sequence(code) {\r\n    if (code === marker) {\r\n      effects.consume(code)\r\n      return sequence\r\n    }\r\n\r\n    const token = effects.exit('attentionSequence')\r\n    const after = classifyCharacter(code)\r\n\r\n    const open =\r\n      !after ||\r\n      (after === constants.characterGroupPunctuation && before) ||\r\n      attentionMarkers.includes(code)\r\n    const close =\r\n      !before ||\r\n      (before === constants.characterGroupPunctuation && after) ||\r\n      attentionMarkers.includes(previous)\r\n\r\n    token._open = Boolean(\r\n      marker === codes.asterisk ? open : open && (before || !close)\r\n    )\r\n    token._close = Boolean(\r\n      marker === codes.asterisk ? close : close && (after || !open)\r\n    )\r\n    return ok(code)\r\n  }\r\n}\r\n\r\n/**\r\n * Move a point a bit.\r\n *\r\n * Note: `move` only works inside lines! It’s not possible to move past other\r\n * chunks (replacement characters, tabs, or line endings).\r\n *\r\n * @param {Point} point\r\n * @param {number} offset\r\n * @returns {void}\r\n */\r\nfunction movePoint(point, offset) {\r\n  point.column += offset\r\n  point.offset += offset\r\n  point._bufferIndex += offset\r\n}\r\n", "/**\r\n * @typedef {import('micromark-util-types').Construct} Construct\r\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\r\n * @typedef {import('micromark-util-types').State} State\r\n */\r\n\r\nimport {ok as assert} from 'uvu/assert'\r\nimport {\r\n  asciiAlpha,\r\n  asciiAlphanumeric,\r\n  asciiAtext,\r\n  asciiControl\r\n} from 'micromark-util-character'\r\nimport {codes} from 'micromark-util-symbol/codes.js'\r\nimport {constants} from 'micromark-util-symbol/constants.js'\r\nimport {types} from 'micromark-util-symbol/types.js'\r\n\r\n/** @type {Construct} */\r\nexport const autolink = {name: 'autolink', tokenize: tokenizeAutolink}\r\n\r\n/** @type {Tokenizer} */\r\nfunction tokenizeAutolink(effects, ok, nok) {\r\n  let size = 1\r\n\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    assert(code === codes.lessThan, 'expected `<`')\r\n    effects.enter(types.autolink)\r\n    effects.enter(types.autolinkMarker)\r\n    effects.consume(code)\r\n    effects.exit(types.autolinkMarker)\r\n    effects.enter(types.autolinkProtocol)\r\n    return open\r\n  }\r\n\r\n  /** @type {State} */\r\n  function open(code) {\r\n    if (asciiAlpha(code)) {\r\n      effects.consume(code)\r\n      return schemeOrEmailAtext\r\n    }\r\n\r\n    return asciiAtext(code) ? emailAtext(code) : nok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function schemeOrEmailAtext(code) {\r\n    return code === codes.plusSign ||\r\n      code === codes.dash ||\r\n      code === codes.dot ||\r\n      asciiAlphanumeric(code)\r\n      ? schemeInsideOrEmailAtext(code)\r\n      : emailAtext(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function schemeInsideOrEmailAtext(code) {\r\n    if (code === codes.colon) {\r\n      effects.consume(code)\r\n      return urlInside\r\n    }\r\n\r\n    if (\r\n      (code === codes.plusSign ||\r\n        code === codes.dash ||\r\n        code === codes.dot ||\r\n        asciiAlphanumeric(code)) &&\r\n      size++ < constants.autolinkSchemeSizeMax\r\n    ) {\r\n      effects.consume(code)\r\n      return schemeInsideOrEmailAtext\r\n    }\r\n\r\n    return emailAtext(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function urlInside(code) {\r\n    if (code === codes.greaterThan) {\r\n      effects.exit(types.autolinkProtocol)\r\n      return end(code)\r\n    }\r\n\r\n    if (\r\n      code === codes.eof ||\r\n      code === codes.space ||\r\n      code === codes.lessThan ||\r\n      asciiControl(code)\r\n    ) {\r\n      return nok(code)\r\n    }\r\n\r\n    effects.consume(code)\r\n    return urlInside\r\n  }\r\n\r\n  /** @type {State} */\r\n  function emailAtext(code) {\r\n    if (code === codes.atSign) {\r\n      effects.consume(code)\r\n      size = 0\r\n      return emailAtSignOrDot\r\n    }\r\n\r\n    if (asciiAtext(code)) {\r\n      effects.consume(code)\r\n      return emailAtext\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function emailAtSignOrDot(code) {\r\n    return asciiAlphanumeric(code) ? emailLabel(code) : nok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function emailLabel(code) {\r\n    if (code === codes.dot) {\r\n      effects.consume(code)\r\n      size = 0\r\n      return emailAtSignOrDot\r\n    }\r\n\r\n    if (code === codes.greaterThan) {\r\n      // Exit, then change the type.\r\n      effects.exit(types.autolinkProtocol).type = types.autolinkEmail\r\n      return end(code)\r\n    }\r\n\r\n    return emailValue(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function emailValue(code) {\r\n    if (\r\n      (code === codes.dash || asciiAlphanumeric(code)) &&\r\n      size++ < constants.autolinkDomainSizeMax\r\n    ) {\r\n      effects.consume(code)\r\n      return code === codes.dash ? emailValue : emailLabel\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function end(code) {\r\n    assert(code === codes.greaterThan, 'expected `>`')\r\n    effects.enter(types.autolinkMarker)\r\n    effects.consume(code)\r\n    effects.exit(types.autolinkMarker)\r\n    effects.exit(types.autolink)\r\n    return ok\r\n  }\r\n}\r\n", "/**\r\n * @typedef {import('micromark-util-types').Construct} Construct\r\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\r\n * @typedef {import('micromark-util-types').Exiter} Exiter\r\n * @typedef {import('micromark-util-types').State} State\r\n */\r\n\r\nimport {ok as assert} from 'uvu/assert'\r\nimport {factorySpace} from 'micromark-factory-space'\r\nimport {markdownSpace} from 'micromark-util-character'\r\nimport {codes} from 'micromark-util-symbol/codes.js'\r\nimport {constants} from 'micromark-util-symbol/constants.js'\r\nimport {types} from 'micromark-util-symbol/types.js'\r\n\r\n/** @type {Construct} */\r\nexport const blockQuote = {\r\n  name: 'blockQuote',\r\n  tokenize: tokenizeBlockQuoteStart,\r\n  continuation: {tokenize: tokenizeBlockQuoteContinuation},\r\n  exit\r\n}\r\n\r\n/** @type {Tokenizer} */\r\nfunction tokenizeBlockQuoteStart(effects, ok, nok) {\r\n  const self = this\r\n\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    if (code === codes.greaterThan) {\r\n      const state = self.containerState\r\n\r\n      assert(state, 'expected `containerState` to be defined in container')\r\n\r\n      if (!state.open) {\r\n        effects.enter(types.blockQuote, {_container: true})\r\n        state.open = true\r\n      }\r\n\r\n      effects.enter(types.blockQuotePrefix)\r\n      effects.enter(types.blockQuoteMarker)\r\n      effects.consume(code)\r\n      effects.exit(types.blockQuoteMarker)\r\n      return after\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function after(code) {\r\n    if (markdownSpace(code)) {\r\n      effects.enter(types.blockQuotePrefixWhitespace)\r\n      effects.consume(code)\r\n      effects.exit(types.blockQuotePrefixWhitespace)\r\n      effects.exit(types.blockQuotePrefix)\r\n      return ok\r\n    }\r\n\r\n    effects.exit(types.blockQuotePrefix)\r\n    return ok(code)\r\n  }\r\n}\r\n\r\n/** @type {Tokenizer} */\r\nfunction tokenizeBlockQuoteContinuation(effects, ok, nok) {\r\n  return factorySpace(\r\n    effects,\r\n    effects.attempt(blockQuote, ok, nok),\r\n    types.linePrefix,\r\n    this.parser.constructs.disable.null.includes('codeIndented')\r\n      ? undefined\r\n      : constants.tabSize\r\n  )\r\n}\r\n\r\n/** @type {Exiter} */\r\nfunction exit(effects) {\r\n  effects.exit(types.blockQuote)\r\n}\r\n", "/**\r\n * @typedef {import('micromark-util-types').Construct} Construct\r\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\r\n * @typedef {import('micromark-util-types').State} State\r\n */\r\n\r\nimport {ok as assert} from 'uvu/assert'\r\nimport {asciiPunctuation} from 'micromark-util-character'\r\nimport {codes} from 'micromark-util-symbol/codes.js'\r\nimport {types} from 'micromark-util-symbol/types.js'\r\n\r\n/** @type {Construct} */\r\nexport const characterEscape = {\r\n  name: 'characterEscape',\r\n  tokenize: tokenizeCharacterEscape\r\n}\r\n\r\n/** @type {Tokenizer} */\r\nfunction tokenizeCharacterEscape(effects, ok, nok) {\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    assert(code === codes.backslash, 'expected `\\\\`')\r\n    effects.enter(types.characterEscape)\r\n    effects.enter(types.escapeMarker)\r\n    effects.consume(code)\r\n    effects.exit(types.escapeMarker)\r\n    return open\r\n  }\r\n\r\n  /** @type {State} */\r\n  function open(code) {\r\n    if (asciiPunctuation(code)) {\r\n      effects.enter(types.characterEscapeValue)\r\n      effects.consume(code)\r\n      effects.exit(types.characterEscapeValue)\r\n      effects.exit(types.characterEscape)\r\n      return ok\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n}\r\n", "/// <reference lib=\"dom\" />\r\n\r\n/* eslint-env browser */\r\n\r\nconst element = document.createElement('i')\r\n\r\n/**\r\n * @param {string} value\r\n * @returns {string|false}\r\n */\r\nexport function decodeNamedCharacterReference(value) {\r\n  const characterReference = '&' + value + ';'\r\n  element.innerHTML = characterReference\r\n  const char = element.textContent\r\n\r\n  // Some named character references do not require the closing semicolon\r\n  // (`&not`, for instance), which leads to situations where parsing the assumed\r\n  // named reference of `&notit;` will result in the string `¬it;`.\r\n  // When we encounter a trailing semicolon after parsing, and the character\r\n  // reference to decode was not a semicolon (`&semi;`), we can assume that the\r\n  // matching was not complete.\r\n  // @ts-expect-error: TypeScript is wrong that `textContent` on elements can\r\n  // yield `null`.\r\n  if (char.charCodeAt(char.length - 1) === 59 /* `;` */ && value !== 'semi') {\r\n    return false\r\n  }\r\n\r\n  // If the decoded string is equal to the input, the character reference was\r\n  // not valid.\r\n  // @ts-expect-error: TypeScript is wrong that `textContent` on elements can\r\n  // yield `null`.\r\n  return char === characterReference ? false : char\r\n}\r\n", "/**\r\n * @typedef {import('micromark-util-types').Construct} Construct\r\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\r\n * @typedef {import('micromark-util-types').Token} Token\r\n * @typedef {import('micromark-util-types').State} State\r\n * @typedef {import('micromark-util-types').Code} Code\r\n */\r\n\r\nimport {ok as assert} from 'uvu/assert'\r\nimport {decodeNamedCharacterReference} from 'decode-named-character-reference'\r\nimport {\r\n  asciiAlphanumeric,\r\n  asciiDigit,\r\n  asciiHexDigit\r\n} from 'micromark-util-character'\r\nimport {codes} from 'micromark-util-symbol/codes.js'\r\nimport {constants} from 'micromark-util-symbol/constants.js'\r\nimport {types} from 'micromark-util-symbol/types.js'\r\n\r\n/** @type {Construct} */\r\nexport const characterReference = {\r\n  name: 'characterReference',\r\n  tokenize: tokenizeCharacterReference\r\n}\r\n\r\n/** @type {Tokenizer} */\r\nfunction tokenizeCharacterReference(effects, ok, nok) {\r\n  const self = this\r\n  let size = 0\r\n  /** @type {number} */\r\n  let max\r\n  /** @type {(code: Code) => code is number} */\r\n  let test\r\n\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    assert(code === codes.ampersand, 'expected `&`')\r\n    effects.enter(types.characterReference)\r\n    effects.enter(types.characterReferenceMarker)\r\n    effects.consume(code)\r\n    effects.exit(types.characterReferenceMarker)\r\n    return open\r\n  }\r\n\r\n  /** @type {State} */\r\n  function open(code) {\r\n    if (code === codes.numberSign) {\r\n      effects.enter(types.characterReferenceMarkerNumeric)\r\n      effects.consume(code)\r\n      effects.exit(types.characterReferenceMarkerNumeric)\r\n      return numeric\r\n    }\r\n\r\n    effects.enter(types.characterReferenceValue)\r\n    max = constants.characterReferenceNamedSizeMax\r\n    test = asciiAlphanumeric\r\n    return value(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function numeric(code) {\r\n    if (code === codes.uppercaseX || code === codes.lowercaseX) {\r\n      effects.enter(types.characterReferenceMarkerHexadecimal)\r\n      effects.consume(code)\r\n      effects.exit(types.characterReferenceMarkerHexadecimal)\r\n      effects.enter(types.characterReferenceValue)\r\n      max = constants.characterReferenceHexadecimalSizeMax\r\n      test = asciiHexDigit\r\n      return value\r\n    }\r\n\r\n    effects.enter(types.characterReferenceValue)\r\n    max = constants.characterReferenceDecimalSizeMax\r\n    test = asciiDigit\r\n    return value(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function value(code) {\r\n    /** @type {Token} */\r\n    let token\r\n\r\n    if (code === codes.semicolon && size) {\r\n      token = effects.exit(types.characterReferenceValue)\r\n\r\n      if (\r\n        test === asciiAlphanumeric &&\r\n        !decodeNamedCharacterReference(self.sliceSerialize(token))\r\n      ) {\r\n        return nok(code)\r\n      }\r\n\r\n      effects.enter(types.characterReferenceMarker)\r\n      effects.consume(code)\r\n      effects.exit(types.characterReferenceMarker)\r\n      effects.exit(types.characterReference)\r\n      return ok\r\n    }\r\n\r\n    if (test(code) && size++ < max) {\r\n      effects.consume(code)\r\n      return value\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n}\r\n", "/**\r\n * @typedef {import('micromark-util-types').Construct} Construct\r\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\r\n * @typedef {import('micromark-util-types').State} State\r\n * @typedef {import('micromark-util-types').Code} Code\r\n */\r\n\r\nimport {ok as assert} from 'uvu/assert'\r\nimport {factorySpace} from 'micromark-factory-space'\r\nimport {\r\n  markdownLineEnding,\r\n  markdownLineEndingOrSpace\r\n} from 'micromark-util-character'\r\nimport {codes} from 'micromark-util-symbol/codes.js'\r\nimport {constants} from 'micromark-util-symbol/constants.js'\r\nimport {types} from 'micromark-util-symbol/types.js'\r\n\r\n/** @type {Construct} */\r\nexport const codeFenced = {\r\n  name: 'codeFenced',\r\n  tokenize: tokenizeCodeFenced,\r\n  concrete: true\r\n}\r\n\r\n/** @type {Tokenizer} */\r\nfunction tokenizeCodeFenced(effects, ok, nok) {\r\n  const self = this\r\n  /** @type {Construct} */\r\n  const closingFenceConstruct = {tokenize: tokenizeClosingFence, partial: true}\r\n  /** @type {Construct} */\r\n  const nonLazyLine = {tokenize: tokenizeNonLazyLine, partial: true}\r\n  const tail = this.events[this.events.length - 1]\r\n  const initialPrefix =\r\n    tail && tail[1].type === types.linePrefix\r\n      ? tail[2].sliceSerialize(tail[1], true).length\r\n      : 0\r\n  let sizeOpen = 0\r\n  /** @type {NonNullable<Code>} */\r\n  let marker\r\n\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    assert(\r\n      code === codes.graveAccent || code === codes.tilde,\r\n      'expected `` ` `` or `~`'\r\n    )\r\n    effects.enter(types.codeFenced)\r\n    effects.enter(types.codeFencedFence)\r\n    effects.enter(types.codeFencedFenceSequence)\r\n    marker = code\r\n    return sequenceOpen(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function sequenceOpen(code) {\r\n    if (code === marker) {\r\n      effects.consume(code)\r\n      sizeOpen++\r\n      return sequenceOpen\r\n    }\r\n\r\n    effects.exit(types.codeFencedFenceSequence)\r\n    return sizeOpen < constants.codeFencedSequenceSizeMin\r\n      ? nok(code)\r\n      : factorySpace(effects, infoOpen, types.whitespace)(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function infoOpen(code) {\r\n    if (code === codes.eof || markdownLineEnding(code)) {\r\n      return openAfter(code)\r\n    }\r\n\r\n    effects.enter(types.codeFencedFenceInfo)\r\n    effects.enter(types.chunkString, {contentType: constants.contentTypeString})\r\n    return info(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function info(code) {\r\n    if (code === codes.eof || markdownLineEndingOrSpace(code)) {\r\n      effects.exit(types.chunkString)\r\n      effects.exit(types.codeFencedFenceInfo)\r\n      return factorySpace(effects, infoAfter, types.whitespace)(code)\r\n    }\r\n\r\n    if (code === codes.graveAccent && code === marker) return nok(code)\r\n    effects.consume(code)\r\n    return info\r\n  }\r\n\r\n  /** @type {State} */\r\n  function infoAfter(code) {\r\n    if (code === codes.eof || markdownLineEnding(code)) {\r\n      return openAfter(code)\r\n    }\r\n\r\n    effects.enter(types.codeFencedFenceMeta)\r\n    effects.enter(types.chunkString, {contentType: constants.contentTypeString})\r\n    return meta(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function meta(code) {\r\n    if (code === codes.eof || markdownLineEnding(code)) {\r\n      effects.exit(types.chunkString)\r\n      effects.exit(types.codeFencedFenceMeta)\r\n      return openAfter(code)\r\n    }\r\n\r\n    if (code === codes.graveAccent && code === marker) return nok(code)\r\n    effects.consume(code)\r\n    return meta\r\n  }\r\n\r\n  /** @type {State} */\r\n  function openAfter(code) {\r\n    effects.exit(types.codeFencedFence)\r\n    return self.interrupt ? ok(code) : contentStart(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function contentStart(code) {\r\n    if (code === codes.eof) {\r\n      return after(code)\r\n    }\r\n\r\n    if (markdownLineEnding(code)) {\r\n      return effects.attempt(\r\n        nonLazyLine,\r\n        effects.attempt(\r\n          closingFenceConstruct,\r\n          after,\r\n          initialPrefix\r\n            ? factorySpace(\r\n                effects,\r\n                contentStart,\r\n                types.linePrefix,\r\n                initialPrefix + 1\r\n              )\r\n            : contentStart\r\n        ),\r\n        after\r\n      )(code)\r\n    }\r\n\r\n    effects.enter(types.codeFlowValue)\r\n    return contentContinue(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function contentContinue(code) {\r\n    if (code === codes.eof || markdownLineEnding(code)) {\r\n      effects.exit(types.codeFlowValue)\r\n      return contentStart(code)\r\n    }\r\n\r\n    effects.consume(code)\r\n    return contentContinue\r\n  }\r\n\r\n  /** @type {State} */\r\n  function after(code) {\r\n    effects.exit(types.codeFenced)\r\n    return ok(code)\r\n  }\r\n\r\n  /** @type {Tokenizer} */\r\n  function tokenizeNonLazyLine(effects, ok, nok) {\r\n    const self = this\r\n\r\n    return start\r\n\r\n    /** @type {State} */\r\n    function start(code) {\r\n      assert(markdownLineEnding(code), 'expected eol')\r\n      effects.enter(types.lineEnding)\r\n      effects.consume(code)\r\n      effects.exit(types.lineEnding)\r\n      return lineStart\r\n    }\r\n\r\n    /** @type {State} */\r\n    function lineStart(code) {\r\n      return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\r\n    }\r\n  }\r\n\r\n  /** @type {Tokenizer} */\r\n  function tokenizeClosingFence(effects, ok, nok) {\r\n    let size = 0\r\n\r\n    return factorySpace(\r\n      effects,\r\n      closingSequenceStart,\r\n      types.linePrefix,\r\n      this.parser.constructs.disable.null.includes('codeIndented')\r\n        ? undefined\r\n        : constants.tabSize\r\n    )\r\n\r\n    /** @type {State} */\r\n    function closingSequenceStart(code) {\r\n      effects.enter(types.codeFencedFence)\r\n      effects.enter(types.codeFencedFenceSequence)\r\n      return closingSequence(code)\r\n    }\r\n\r\n    /** @type {State} */\r\n    function closingSequence(code) {\r\n      if (code === marker) {\r\n        effects.consume(code)\r\n        size++\r\n        return closingSequence\r\n      }\r\n\r\n      if (size < sizeOpen) return nok(code)\r\n      effects.exit(types.codeFencedFenceSequence)\r\n      return factorySpace(effects, closingSequenceEnd, types.whitespace)(code)\r\n    }\r\n\r\n    /** @type {State} */\r\n    function closingSequenceEnd(code) {\r\n      if (code === codes.eof || markdownLineEnding(code)) {\r\n        effects.exit(types.codeFencedFence)\r\n        return ok(code)\r\n      }\r\n\r\n      return nok(code)\r\n    }\r\n  }\r\n}\r\n", "/**\r\n * @typedef {import('micromark-util-types').Construct} Construct\r\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\r\n * @typedef {import('micromark-util-types').Resolver} Resolver\r\n * @typedef {import('micromark-util-types').Token} Token\r\n * @typedef {import('micromark-util-types').State} State\r\n */\r\n\r\nimport {factorySpace} from 'micromark-factory-space'\r\nimport {markdownLineEnding} from 'micromark-util-character'\r\nimport {codes} from 'micromark-util-symbol/codes.js'\r\nimport {constants} from 'micromark-util-symbol/constants.js'\r\nimport {types} from 'micromark-util-symbol/types.js'\r\n\r\n/** @type {Construct} */\r\nexport const codeIndented = {\r\n  name: 'codeIndented',\r\n  tokenize: tokenizeCodeIndented\r\n}\r\n\r\n/** @type {Construct} */\r\nconst indentedContent = {tokenize: tokenizeIndentedContent, partial: true}\r\n\r\n/** @type {Tokenizer} */\r\nfunction tokenizeCodeIndented(effects, ok, nok) {\r\n  const self = this\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    effects.enter(types.codeIndented)\r\n    return factorySpace(\r\n      effects,\r\n      afterStartPrefix,\r\n      types.linePrefix,\r\n      constants.tabSize + 1\r\n    )(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function afterStartPrefix(code) {\r\n    const tail = self.events[self.events.length - 1]\r\n    return tail &&\r\n      tail[1].type === types.linePrefix &&\r\n      tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize\r\n      ? afterPrefix(code)\r\n      : nok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function afterPrefix(code) {\r\n    if (code === codes.eof) {\r\n      return after(code)\r\n    }\r\n\r\n    if (markdownLineEnding(code)) {\r\n      return effects.attempt(indentedContent, afterPrefix, after)(code)\r\n    }\r\n\r\n    effects.enter(types.codeFlowValue)\r\n    return content(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function content(code) {\r\n    if (code === codes.eof || markdownLineEnding(code)) {\r\n      effects.exit(types.codeFlowValue)\r\n      return afterPrefix(code)\r\n    }\r\n\r\n    effects.consume(code)\r\n    return content\r\n  }\r\n\r\n  /** @type {State} */\r\n  function after(code) {\r\n    effects.exit(types.codeIndented)\r\n    return ok(code)\r\n  }\r\n}\r\n\r\n/** @type {Tokenizer} */\r\nfunction tokenizeIndentedContent(effects, ok, nok) {\r\n  const self = this\r\n\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    // If this is a lazy line, it can’t be code.\r\n    if (self.parser.lazy[self.now().line]) {\r\n      return nok(code)\r\n    }\r\n\r\n    if (markdownLineEnding(code)) {\r\n      effects.enter(types.lineEnding)\r\n      effects.consume(code)\r\n      effects.exit(types.lineEnding)\r\n      return start\r\n    }\r\n\r\n    return factorySpace(\r\n      effects,\r\n      afterPrefix,\r\n      types.linePrefix,\r\n      constants.tabSize + 1\r\n    )(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function afterPrefix(code) {\r\n    const tail = self.events[self.events.length - 1]\r\n    return tail &&\r\n      tail[1].type === types.linePrefix &&\r\n      tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize\r\n      ? ok(code)\r\n      : markdownLineEnding(code)\r\n      ? start(code)\r\n      : nok(code)\r\n  }\r\n}\r\n", "/**\r\n * @typedef {import('micromark-util-types').Construct} Construct\r\n * @typedef {import('micromark-util-types').Resolver} Resolver\r\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\r\n * @typedef {import('micromark-util-types').Previous} Previous\r\n * @typedef {import('micromark-util-types').Token} Token\r\n * @typedef {import('micromark-util-types').State} State\r\n */\r\n\r\nimport {ok as assert} from 'uvu/assert'\r\nimport {markdownLineEnding} from 'micromark-util-character'\r\nimport {codes} from 'micromark-util-symbol/codes.js'\r\nimport {types} from 'micromark-util-symbol/types.js'\r\n\r\n/** @type {Construct} */\r\nexport const codeText = {\r\n  name: 'codeText',\r\n  tokenize: tokenizeCodeText,\r\n  resolve: resolveCodeText,\r\n  previous\r\n}\r\n\r\n/** @type {Resolver} */\r\nfunction resolveCodeText(events) {\r\n  let tailExitIndex = events.length - 4\r\n  let headEnterIndex = 3\r\n  /** @type {number} */\r\n  let index\r\n  /** @type {number|undefined} */\r\n  let enter\r\n\r\n  // If we start and end with an EOL or a space.\r\n  if (\r\n    (events[headEnterIndex][1].type === types.lineEnding ||\r\n      events[headEnterIndex][1].type === 'space') &&\r\n    (events[tailExitIndex][1].type === types.lineEnding ||\r\n      events[tailExitIndex][1].type === 'space')\r\n  ) {\r\n    index = headEnterIndex\r\n\r\n    // And we have data.\r\n    while (++index < tailExitIndex) {\r\n      if (events[index][1].type === types.codeTextData) {\r\n        // Then we have padding.\r\n        events[headEnterIndex][1].type = types.codeTextPadding\r\n        events[tailExitIndex][1].type = types.codeTextPadding\r\n        headEnterIndex += 2\r\n        tailExitIndex -= 2\r\n        break\r\n      }\r\n    }\r\n  }\r\n\r\n  // Merge adjacent spaces and data.\r\n  index = headEnterIndex - 1\r\n  tailExitIndex++\r\n\r\n  while (++index <= tailExitIndex) {\r\n    if (enter === undefined) {\r\n      if (\r\n        index !== tailExitIndex &&\r\n        events[index][1].type !== types.lineEnding\r\n      ) {\r\n        enter = index\r\n      }\r\n    } else if (\r\n      index === tailExitIndex ||\r\n      events[index][1].type === types.lineEnding\r\n    ) {\r\n      events[enter][1].type = types.codeTextData\r\n\r\n      if (index !== enter + 2) {\r\n        events[enter][1].end = events[index - 1][1].end\r\n        events.splice(enter + 2, index - enter - 2)\r\n        tailExitIndex -= index - enter - 2\r\n        index = enter + 2\r\n      }\r\n\r\n      enter = undefined\r\n    }\r\n  }\r\n\r\n  return events\r\n}\r\n\r\n/** @type {Previous} */\r\nfunction previous(code) {\r\n  // If there is a previous code, there will always be a tail.\r\n  return (\r\n    code !== codes.graveAccent ||\r\n    this.events[this.events.length - 1][1].type === types.characterEscape\r\n  )\r\n}\r\n\r\n/** @type {Tokenizer} */\r\nfunction tokenizeCodeText(effects, ok, nok) {\r\n  const self = this\r\n  let sizeOpen = 0\r\n  /** @type {number} */\r\n  let size\r\n  /** @type {Token} */\r\n  let token\r\n\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    assert(code === codes.graveAccent, 'expected `` ` ``')\r\n    assert(previous.call(self, self.previous), 'expected correct previous')\r\n    effects.enter(types.codeText)\r\n    effects.enter(types.codeTextSequence)\r\n    return openingSequence(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function openingSequence(code) {\r\n    if (code === codes.graveAccent) {\r\n      effects.consume(code)\r\n      sizeOpen++\r\n      return openingSequence\r\n    }\r\n\r\n    effects.exit(types.codeTextSequence)\r\n    return gap(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function gap(code) {\r\n    // EOF.\r\n    if (code === codes.eof) {\r\n      return nok(code)\r\n    }\r\n\r\n    // Closing fence?\r\n    // Could also be data.\r\n    if (code === codes.graveAccent) {\r\n      token = effects.enter(types.codeTextSequence)\r\n      size = 0\r\n      return closingSequence(code)\r\n    }\r\n\r\n    // Tabs don’t work, and virtual spaces don’t make sense.\r\n    if (code === codes.space) {\r\n      effects.enter('space')\r\n      effects.consume(code)\r\n      effects.exit('space')\r\n      return gap\r\n    }\r\n\r\n    if (markdownLineEnding(code)) {\r\n      effects.enter(types.lineEnding)\r\n      effects.consume(code)\r\n      effects.exit(types.lineEnding)\r\n      return gap\r\n    }\r\n\r\n    // Data.\r\n    effects.enter(types.codeTextData)\r\n    return data(code)\r\n  }\r\n\r\n  // In code.\r\n  /** @type {State} */\r\n  function data(code) {\r\n    if (\r\n      code === codes.eof ||\r\n      code === codes.space ||\r\n      code === codes.graveAccent ||\r\n      markdownLineEnding(code)\r\n    ) {\r\n      effects.exit(types.codeTextData)\r\n      return gap(code)\r\n    }\r\n\r\n    effects.consume(code)\r\n    return data\r\n  }\r\n\r\n  // Closing fence.\r\n  /** @type {State} */\r\n  function closingSequence(code) {\r\n    // More.\r\n    if (code === codes.graveAccent) {\r\n      effects.consume(code)\r\n      size++\r\n      return closingSequence\r\n    }\r\n\r\n    // Done!\r\n    if (size === sizeOpen) {\r\n      effects.exit(types.codeTextSequence)\r\n      effects.exit(types.codeText)\r\n      return ok(code)\r\n    }\r\n\r\n    // More or less accents: mark as data.\r\n    token.type = types.codeTextData\r\n    return data(code)\r\n  }\r\n}\r\n", "/**\r\n * @typedef {import('micromark-util-types').Token} Token\r\n * @typedef {import('micromark-util-types').Chunk} Chunk\r\n * @typedef {import('micromark-util-types').Event} Event\r\n */\r\n\r\nimport {ok as assert} from 'uvu/assert'\r\nimport {splice} from 'micromark-util-chunked'\r\nimport {codes} from 'micromark-util-symbol/codes.js'\r\nimport {types} from 'micromark-util-symbol/types.js'\r\n\r\n/**\r\n * Tokenize subcontent.\r\n *\r\n * @param {Event[]} events\r\n * @returns {boolean}\r\n */\r\nexport function subtokenize(events) {\r\n  /** @type {Record<string, number>} */\r\n  const jumps = {}\r\n  let index = -1\r\n  /** @type {Event} */\r\n  let event\r\n  /** @type {number|undefined} */\r\n  let lineIndex\r\n  /** @type {number} */\r\n  let otherIndex\r\n  /** @type {Event} */\r\n  let otherEvent\r\n  /** @type {Event[]} */\r\n  let parameters\r\n  /** @type {Event[]} */\r\n  let subevents\r\n  /** @type {boolean|undefined} */\r\n  let more\r\n\r\n  while (++index < events.length) {\r\n    while (index in jumps) {\r\n      index = jumps[index]\r\n    }\r\n\r\n    event = events[index]\r\n\r\n    // Add a hook for the GFM tasklist extension, which needs to know if text\r\n    // is in the first content of a list item.\r\n    if (\r\n      index &&\r\n      event[1].type === types.chunkFlow &&\r\n      events[index - 1][1].type === types.listItemPrefix\r\n    ) {\r\n      assert(event[1]._tokenizer, 'expected `_tokenizer` on subtokens')\r\n      subevents = event[1]._tokenizer.events\r\n      otherIndex = 0\r\n\r\n      if (\r\n        otherIndex < subevents.length &&\r\n        subevents[otherIndex][1].type === types.lineEndingBlank\r\n      ) {\r\n        otherIndex += 2\r\n      }\r\n\r\n      if (\r\n        otherIndex < subevents.length &&\r\n        subevents[otherIndex][1].type === types.content\r\n      ) {\r\n        while (++otherIndex < subevents.length) {\r\n          if (subevents[otherIndex][1].type === types.content) {\r\n            break\r\n          }\r\n\r\n          if (subevents[otherIndex][1].type === types.chunkText) {\r\n            subevents[otherIndex][1]._isInFirstContentOfListItem = true\r\n            otherIndex++\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Enter.\r\n    if (event[0] === 'enter') {\r\n      if (event[1].contentType) {\r\n        Object.assign(jumps, subcontent(events, index))\r\n        index = jumps[index]\r\n        more = true\r\n      }\r\n    }\r\n    // Exit.\r\n    else if (event[1]._container) {\r\n      otherIndex = index\r\n      lineIndex = undefined\r\n\r\n      while (otherIndex--) {\r\n        otherEvent = events[otherIndex]\r\n\r\n        if (\r\n          otherEvent[1].type === types.lineEnding ||\r\n          otherEvent[1].type === types.lineEndingBlank\r\n        ) {\r\n          if (otherEvent[0] === 'enter') {\r\n            if (lineIndex) {\r\n              events[lineIndex][1].type = types.lineEndingBlank\r\n            }\r\n\r\n            otherEvent[1].type = types.lineEnding\r\n            lineIndex = otherIndex\r\n          }\r\n        } else {\r\n          break\r\n        }\r\n      }\r\n\r\n      if (lineIndex) {\r\n        // Fix position.\r\n        event[1].end = Object.assign({}, events[lineIndex][1].start)\r\n\r\n        // Switch container exit w/ line endings.\r\n        parameters = events.slice(lineIndex, index)\r\n        parameters.unshift(event)\r\n        splice(events, lineIndex, index - lineIndex + 1, parameters)\r\n      }\r\n    }\r\n  }\r\n\r\n  return !more\r\n}\r\n\r\n/**\r\n * Tokenize embedded tokens.\r\n *\r\n * @param {Event[]} events\r\n * @param {number} eventIndex\r\n * @returns {Record<string, number>}\r\n */\r\nfunction subcontent(events, eventIndex) {\r\n  const token = events[eventIndex][1]\r\n  const context = events[eventIndex][2]\r\n  let startPosition = eventIndex - 1\r\n  /** @type {number[]} */\r\n  const startPositions = []\r\n  assert(token.contentType, 'expected `contentType` on subtokens')\r\n  const tokenizer =\r\n    token._tokenizer || context.parser[token.contentType](token.start)\r\n  const childEvents = tokenizer.events\r\n  /** @type {[number, number][]} */\r\n  const jumps = []\r\n  /** @type {Record<string, number>} */\r\n  const gaps = {}\r\n  /** @type {Chunk[]} */\r\n  let stream\r\n  /** @type {Token|undefined} */\r\n  let previous\r\n  let index = -1\r\n  /** @type {Token|undefined} */\r\n  let current = token\r\n  let adjust = 0\r\n  let start = 0\r\n  const breaks = [start]\r\n\r\n  // Loop forward through the linked tokens to pass them in order to the\r\n  // subtokenizer.\r\n  while (current) {\r\n    // Find the position of the event for this token.\r\n    while (events[++startPosition][1] !== current) {\r\n      // Empty.\r\n    }\r\n\r\n    assert(\r\n      !previous || current.previous === previous,\r\n      'expected previous to match'\r\n    )\r\n    assert(!previous || previous.next === current, 'expected next to match')\r\n\r\n    startPositions.push(startPosition)\r\n\r\n    if (!current._tokenizer) {\r\n      stream = context.sliceStream(current)\r\n\r\n      if (!current.next) {\r\n        stream.push(codes.eof)\r\n      }\r\n\r\n      if (previous) {\r\n        tokenizer.defineSkip(current.start)\r\n      }\r\n\r\n      if (current._isInFirstContentOfListItem) {\r\n        tokenizer._gfmTasklistFirstContentOfListItem = true\r\n      }\r\n\r\n      tokenizer.write(stream)\r\n\r\n      if (current._isInFirstContentOfListItem) {\r\n        tokenizer._gfmTasklistFirstContentOfListItem = undefined\r\n      }\r\n    }\r\n\r\n    // Unravel the next token.\r\n    previous = current\r\n    current = current.next\r\n  }\r\n\r\n  // Now, loop back through all events (and linked tokens), to figure out which\r\n  // parts belong where.\r\n  current = token\r\n\r\n  while (++index < childEvents.length) {\r\n    if (\r\n      // Find a void token that includes a break.\r\n      childEvents[index][0] === 'exit' &&\r\n      childEvents[index - 1][0] === 'enter' &&\r\n      childEvents[index][1].type === childEvents[index - 1][1].type &&\r\n      childEvents[index][1].start.line !== childEvents[index][1].end.line\r\n    ) {\r\n      assert(current, 'expected a current token')\r\n      start = index + 1\r\n      breaks.push(start)\r\n      // Help GC.\r\n      current._tokenizer = undefined\r\n      current.previous = undefined\r\n      current = current.next\r\n    }\r\n  }\r\n\r\n  // Help GC.\r\n  tokenizer.events = []\r\n\r\n  // If there’s one more token (which is the cases for lines that end in an\r\n  // EOF), that’s perfect: the last point we found starts it.\r\n  // If there isn’t then make sure any remaining content is added to it.\r\n  if (current) {\r\n    // Help GC.\r\n    current._tokenizer = undefined\r\n    current.previous = undefined\r\n    assert(!current.next, 'expected no next token')\r\n  } else {\r\n    breaks.pop()\r\n  }\r\n\r\n  // Now splice the events from the subtokenizer into the current events,\r\n  // moving back to front so that splice indices aren’t affected.\r\n  index = breaks.length\r\n\r\n  while (index--) {\r\n    const slice = childEvents.slice(breaks[index], breaks[index + 1])\r\n    const start = startPositions.pop()\r\n    assert(start !== undefined, 'expected a start position when splicing')\r\n    jumps.unshift([start, start + slice.length - 1])\r\n    splice(events, start, 2, slice)\r\n  }\r\n\r\n  index = -1\r\n\r\n  while (++index < jumps.length) {\r\n    gaps[adjust + jumps[index][0]] = adjust + jumps[index][1]\r\n    adjust += jumps[index][1] - jumps[index][0] - 1\r\n  }\r\n\r\n  return gaps\r\n}\r\n", "/**\r\n * @typedef {import('micromark-util-types').Construct} Construct\r\n * @typedef {import('micromark-util-types').Resolver} Resolver\r\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\r\n * @typedef {import('micromark-util-types').Token} Token\r\n * @typedef {import('micromark-util-types').State} State\r\n */\r\n\r\nimport {ok as assert} from 'uvu/assert'\r\nimport {factorySpace} from 'micromark-factory-space'\r\nimport {markdownLineEnding} from 'micromark-util-character'\r\nimport {subtokenize} from 'micromark-util-subtokenize'\r\nimport {codes} from 'micromark-util-symbol/codes.js'\r\nimport {constants} from 'micromark-util-symbol/constants.js'\r\nimport {types} from 'micromark-util-symbol/types.js'\r\n\r\n/**\r\n * No name because it must not be turned off.\r\n * @type {Construct}\r\n */\r\nexport const content = {tokenize: tokenizeContent, resolve: resolveContent}\r\n\r\n/** @type {Construct} */\r\nconst continuationConstruct = {tokenize: tokenizeContinuation, partial: true}\r\n\r\n/**\r\n * Content is transparent: it’s parsed right now. That way, definitions are also\r\n * parsed right now: before text in paragraphs (specifically, media) are parsed.\r\n *\r\n * @type {Resolver}\r\n */\r\nfunction resolveContent(events) {\r\n  subtokenize(events)\r\n  return events\r\n}\r\n\r\n/** @type {Tokenizer} */\r\nfunction tokenizeContent(effects, ok) {\r\n  /** @type {Token} */\r\n  let previous\r\n\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    assert(\r\n      code !== codes.eof && !markdownLineEnding(code),\r\n      'expected no eof or eol'\r\n    )\r\n\r\n    effects.enter(types.content)\r\n    previous = effects.enter(types.chunkContent, {\r\n      contentType: constants.contentTypeContent\r\n    })\r\n    return data(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function data(code) {\r\n    if (code === codes.eof) {\r\n      return contentEnd(code)\r\n    }\r\n\r\n    if (markdownLineEnding(code)) {\r\n      return effects.check(\r\n        continuationConstruct,\r\n        contentContinue,\r\n        contentEnd\r\n      )(code)\r\n    }\r\n\r\n    // Data.\r\n    effects.consume(code)\r\n    return data\r\n  }\r\n\r\n  /** @type {State} */\r\n  function contentEnd(code) {\r\n    effects.exit(types.chunkContent)\r\n    effects.exit(types.content)\r\n    return ok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function contentContinue(code) {\r\n    assert(markdownLineEnding(code), 'expected eol')\r\n    effects.consume(code)\r\n    effects.exit(types.chunkContent)\r\n    previous.next = effects.enter(types.chunkContent, {\r\n      contentType: constants.contentTypeContent,\r\n      previous\r\n    })\r\n    previous = previous.next\r\n    return data\r\n  }\r\n}\r\n\r\n/** @type {Tokenizer} */\r\nfunction tokenizeContinuation(effects, ok, nok) {\r\n  const self = this\r\n\r\n  return startLookahead\r\n\r\n  /** @type {State} */\r\n  function startLookahead(code) {\r\n    assert(markdownLineEnding(code), 'expected a line ending')\r\n    effects.exit(types.chunkContent)\r\n    effects.enter(types.lineEnding)\r\n    effects.consume(code)\r\n    effects.exit(types.lineEnding)\r\n    return factorySpace(effects, prefixed, types.linePrefix)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function prefixed(code) {\r\n    if (code === codes.eof || markdownLineEnding(code)) {\r\n      return nok(code)\r\n    }\r\n\r\n    const tail = self.events[self.events.length - 1]\r\n\r\n    if (\r\n      !self.parser.constructs.disable.null.includes('codeIndented') &&\r\n      tail &&\r\n      tail[1].type === types.linePrefix &&\r\n      tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize\r\n    ) {\r\n      return ok(code)\r\n    }\r\n\r\n    return effects.interrupt(self.parser.constructs.flow, nok, ok)(code)\r\n  }\r\n}\r\n", "/**\r\n * @typedef {import('micromark-util-types').Effects} Effects\r\n * @typedef {import('micromark-util-types').State} State\r\n */\r\n\r\nimport {\r\n  asciiControl,\r\n  markdownLineEndingOrSpace,\r\n  markdownLineEnding\r\n} from 'micromark-util-character'\r\nimport {codes} from 'micromark-util-symbol/codes.js'\r\nimport {constants} from 'micromark-util-symbol/constants.js'\r\nimport {types} from 'micromark-util-symbol/types.js'\r\n\r\n/**\r\n * @param {Effects} effects\r\n * @param {State} ok\r\n * @param {State} nok\r\n * @param {string} type\r\n * @param {string} literalType\r\n * @param {string} literalMarkerType\r\n * @param {string} rawType\r\n * @param {string} stringType\r\n * @param {number} [max=Infinity]\r\n * @returns {State}\r\n */\r\n// eslint-disable-next-line max-params\r\nexport function factoryDestination(\r\n  effects,\r\n  ok,\r\n  nok,\r\n  type,\r\n  literalType,\r\n  literalMarkerType,\r\n  rawType,\r\n  stringType,\r\n  max\r\n) {\r\n  const limit = max || Number.POSITIVE_INFINITY\r\n  let balance = 0\r\n\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    if (code === codes.lessThan) {\r\n      effects.enter(type)\r\n      effects.enter(literalType)\r\n      effects.enter(literalMarkerType)\r\n      effects.consume(code)\r\n      effects.exit(literalMarkerType)\r\n      return destinationEnclosedBefore\r\n    }\r\n\r\n    if (\r\n      code === codes.eof ||\r\n      code === codes.rightParenthesis ||\r\n      asciiControl(code)\r\n    ) {\r\n      return nok(code)\r\n    }\r\n\r\n    effects.enter(type)\r\n    effects.enter(rawType)\r\n    effects.enter(stringType)\r\n    effects.enter(types.chunkString, {contentType: constants.contentTypeString})\r\n    return destinationRaw(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function destinationEnclosedBefore(code) {\r\n    if (code === codes.greaterThan) {\r\n      effects.enter(literalMarkerType)\r\n      effects.consume(code)\r\n      effects.exit(literalMarkerType)\r\n      effects.exit(literalType)\r\n      effects.exit(type)\r\n      return ok\r\n    }\r\n\r\n    effects.enter(stringType)\r\n    effects.enter(types.chunkString, {contentType: constants.contentTypeString})\r\n    return destinationEnclosed(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function destinationEnclosed(code) {\r\n    if (code === codes.greaterThan) {\r\n      effects.exit(types.chunkString)\r\n      effects.exit(stringType)\r\n      return destinationEnclosedBefore(code)\r\n    }\r\n\r\n    if (\r\n      code === codes.eof ||\r\n      code === codes.lessThan ||\r\n      markdownLineEnding(code)\r\n    ) {\r\n      return nok(code)\r\n    }\r\n\r\n    effects.consume(code)\r\n    return code === codes.backslash\r\n      ? destinationEnclosedEscape\r\n      : destinationEnclosed\r\n  }\r\n\r\n  /** @type {State} */\r\n  function destinationEnclosedEscape(code) {\r\n    if (\r\n      code === codes.lessThan ||\r\n      code === codes.greaterThan ||\r\n      code === codes.backslash\r\n    ) {\r\n      effects.consume(code)\r\n      return destinationEnclosed\r\n    }\r\n\r\n    return destinationEnclosed(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function destinationRaw(code) {\r\n    if (code === codes.leftParenthesis) {\r\n      if (++balance > limit) return nok(code)\r\n      effects.consume(code)\r\n      return destinationRaw\r\n    }\r\n\r\n    if (code === codes.rightParenthesis) {\r\n      if (!balance--) {\r\n        effects.exit(types.chunkString)\r\n        effects.exit(stringType)\r\n        effects.exit(rawType)\r\n        effects.exit(type)\r\n        return ok(code)\r\n      }\r\n\r\n      effects.consume(code)\r\n      return destinationRaw\r\n    }\r\n\r\n    if (code === codes.eof || markdownLineEndingOrSpace(code)) {\r\n      if (balance) return nok(code)\r\n      effects.exit(types.chunkString)\r\n      effects.exit(stringType)\r\n      effects.exit(rawType)\r\n      effects.exit(type)\r\n      return ok(code)\r\n    }\r\n\r\n    if (asciiControl(code)) return nok(code)\r\n    effects.consume(code)\r\n    return code === codes.backslash ? destinationRawEscape : destinationRaw\r\n  }\r\n\r\n  /** @type {State} */\r\n  function destinationRawEscape(code) {\r\n    if (\r\n      code === codes.leftParenthesis ||\r\n      code === codes.rightParenthesis ||\r\n      code === codes.backslash\r\n    ) {\r\n      effects.consume(code)\r\n      return destinationRaw\r\n    }\r\n\r\n    return destinationRaw(code)\r\n  }\r\n}\r\n", "/**\r\n * @typedef {import('micromark-util-types').Effects} Effects\r\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\r\n * @typedef {import('micromark-util-types').State} State\r\n */\r\n\r\nimport {ok as assert} from 'uvu/assert'\r\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\r\nimport {codes} from 'micromark-util-symbol/codes.js'\r\nimport {constants} from 'micromark-util-symbol/constants.js'\r\nimport {types} from 'micromark-util-symbol/types.js'\r\n\r\n/**\r\n * @this {TokenizeContext}\r\n * @param {Effects} effects\r\n * @param {State} ok\r\n * @param {State} nok\r\n * @param {string} type\r\n * @param {string} markerType\r\n * @param {string} stringType\r\n * @returns {State}\r\n */\r\n// eslint-disable-next-line max-params\r\nexport function factoryLabel(effects, ok, nok, type, markerType, stringType) {\r\n  const self = this\r\n  let size = 0\r\n  /** @type {boolean} */\r\n  let data\r\n\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    assert(code === codes.leftSquareBracket, 'expected `[`')\r\n    effects.enter(type)\r\n    effects.enter(markerType)\r\n    effects.consume(code)\r\n    effects.exit(markerType)\r\n    effects.enter(stringType)\r\n    return atBreak\r\n  }\r\n\r\n  /** @type {State} */\r\n  function atBreak(code) {\r\n    if (\r\n      code === codes.eof ||\r\n      code === codes.leftSquareBracket ||\r\n      (code === codes.rightSquareBracket && !data) ||\r\n      /* To do: remove in the future once we’ve switched from\r\n       * `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,\r\n       * which doesn’t need this */\r\n      /* Hidden footnotes hook */\r\n      /* c8 ignore next 3 */\r\n      (code === codes.caret &&\r\n        !size &&\r\n        '_hiddenFootnoteSupport' in self.parser.constructs) ||\r\n      size > constants.linkReferenceSizeMax\r\n    ) {\r\n      return nok(code)\r\n    }\r\n\r\n    if (code === codes.rightSquareBracket) {\r\n      effects.exit(stringType)\r\n      effects.enter(markerType)\r\n      effects.consume(code)\r\n      effects.exit(markerType)\r\n      effects.exit(type)\r\n      return ok\r\n    }\r\n\r\n    if (markdownLineEnding(code)) {\r\n      effects.enter(types.lineEnding)\r\n      effects.consume(code)\r\n      effects.exit(types.lineEnding)\r\n      return atBreak\r\n    }\r\n\r\n    effects.enter(types.chunkString, {contentType: constants.contentTypeString})\r\n    return label(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function label(code) {\r\n    if (\r\n      code === codes.eof ||\r\n      code === codes.leftSquareBracket ||\r\n      code === codes.rightSquareBracket ||\r\n      markdownLineEnding(code) ||\r\n      size++ > constants.linkReferenceSizeMax\r\n    ) {\r\n      effects.exit(types.chunkString)\r\n      return atBreak(code)\r\n    }\r\n\r\n    effects.consume(code)\r\n    data = data || !markdownSpace(code)\r\n    return code === codes.backslash ? labelEscape : label\r\n  }\r\n\r\n  /** @type {State} */\r\n  function labelEscape(code) {\r\n    if (\r\n      code === codes.leftSquareBracket ||\r\n      code === codes.backslash ||\r\n      code === codes.rightSquareBracket\r\n    ) {\r\n      effects.consume(code)\r\n      size++\r\n      return label\r\n    }\r\n\r\n    return label(code)\r\n  }\r\n}\r\n", "/**\r\n * @typedef {import('micromark-util-types').Effects} Effects\r\n * @typedef {import('micromark-util-types').State} State\r\n * @typedef {import('micromark-util-types').Code} Code\r\n */\r\n\r\nimport {ok as assert} from 'uvu/assert'\r\nimport {factorySpace} from 'micromark-factory-space'\r\nimport {markdownLineEnding} from 'micromark-util-character'\r\nimport {codes} from 'micromark-util-symbol/codes.js'\r\nimport {constants} from 'micromark-util-symbol/constants.js'\r\nimport {types} from 'micromark-util-symbol/types.js'\r\n\r\n/**\r\n * @param {Effects} effects\r\n * @param {State} ok\r\n * @param {State} nok\r\n * @param {string} type\r\n * @param {string} markerType\r\n * @param {string} stringType\r\n * @returns {State}\r\n */\r\n// eslint-disable-next-line max-params\r\nexport function factoryTitle(effects, ok, nok, type, markerType, stringType) {\r\n  /** @type {NonNullable<Code>} */\r\n  let marker\r\n\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    assert(\r\n      code === codes.quotationMark ||\r\n        code === codes.apostrophe ||\r\n        code === codes.leftParenthesis,\r\n      'expected `\"`, `\\'`, or `(`'\r\n    )\r\n    effects.enter(type)\r\n    effects.enter(markerType)\r\n    effects.consume(code)\r\n    effects.exit(markerType)\r\n    marker = code === codes.leftParenthesis ? codes.rightParenthesis : code\r\n    return atFirstTitleBreak\r\n  }\r\n\r\n  /** @type {State} */\r\n  function atFirstTitleBreak(code) {\r\n    if (code === marker) {\r\n      effects.enter(markerType)\r\n      effects.consume(code)\r\n      effects.exit(markerType)\r\n      effects.exit(type)\r\n      return ok\r\n    }\r\n\r\n    effects.enter(stringType)\r\n    return atTitleBreak(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function atTitleBreak(code) {\r\n    if (code === marker) {\r\n      effects.exit(stringType)\r\n      return atFirstTitleBreak(marker)\r\n    }\r\n\r\n    if (code === codes.eof) {\r\n      return nok(code)\r\n    }\r\n\r\n    // Note: blank lines can’t exist in content.\r\n    if (markdownLineEnding(code)) {\r\n      effects.enter(types.lineEnding)\r\n      effects.consume(code)\r\n      effects.exit(types.lineEnding)\r\n      return factorySpace(effects, atTitleBreak, types.linePrefix)\r\n    }\r\n\r\n    effects.enter(types.chunkString, {contentType: constants.contentTypeString})\r\n    return title(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function title(code) {\r\n    if (code === marker || code === codes.eof || markdownLineEnding(code)) {\r\n      effects.exit(types.chunkString)\r\n      return atTitleBreak(code)\r\n    }\r\n\r\n    effects.consume(code)\r\n    return code === codes.backslash ? titleEscape : title\r\n  }\r\n\r\n  /** @type {State} */\r\n  function titleEscape(code) {\r\n    if (code === marker || code === codes.backslash) {\r\n      effects.consume(code)\r\n      return title\r\n    }\r\n\r\n    return title(code)\r\n  }\r\n}\r\n", "/**\r\n * @typedef {import('micromark-util-types').Effects} Effects\r\n * @typedef {import('micromark-util-types').State} State\r\n */\r\n\r\nimport {factorySpace} from 'micromark-factory-space'\r\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\r\nimport {types} from 'micromark-util-symbol/types.js'\r\n\r\n/**\r\n * @param {Effects} effects\r\n * @param {State} ok\r\n */\r\nexport function factoryWhitespace(effects, ok) {\r\n  /** @type {boolean} */\r\n  let seen\r\n\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    if (markdownLineEnding(code)) {\r\n      effects.enter(types.lineEnding)\r\n      effects.consume(code)\r\n      effects.exit(types.lineEnding)\r\n      seen = true\r\n      return start\r\n    }\r\n\r\n    if (markdownSpace(code)) {\r\n      return factorySpace(\r\n        effects,\r\n        start,\r\n        seen ? types.linePrefix : types.lineSuffix\r\n      )(code)\r\n    }\r\n\r\n    return ok(code)\r\n  }\r\n}\r\n", "/**\r\n * @typedef {import('micromark-util-types').Construct} Construct\r\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\r\n * @typedef {import('micromark-util-types').State} State\r\n */\r\n\r\nimport {ok as assert} from 'uvu/assert'\r\nimport {factoryDestination} from 'micromark-factory-destination'\r\nimport {factoryLabel} from 'micromark-factory-label'\r\nimport {factorySpace} from 'micromark-factory-space'\r\nimport {factoryTitle} from 'micromark-factory-title'\r\nimport {factoryWhitespace} from 'micromark-factory-whitespace'\r\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\r\nimport {\r\n  markdownLineEnding,\r\n  markdownLineEndingOrSpace\r\n} from 'micromark-util-character'\r\nimport {codes} from 'micromark-util-symbol/codes.js'\r\nimport {types} from 'micromark-util-symbol/types.js'\r\n\r\n/** @type {Construct} */\r\nexport const definition = {name: 'definition', tokenize: tokenizeDefinition}\r\n\r\n/** @type {Construct} */\r\nconst titleConstruct = {tokenize: tokenizeTitle, partial: true}\r\n\r\n/** @type {Tokenizer} */\r\nfunction tokenizeDefinition(effects, ok, nok) {\r\n  const self = this\r\n  /** @type {string} */\r\n  let identifier\r\n\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    assert(code === codes.leftSquareBracket, 'expected `[`')\r\n    effects.enter(types.definition)\r\n    return factoryLabel.call(\r\n      self,\r\n      effects,\r\n      labelAfter,\r\n      nok,\r\n      types.definitionLabel,\r\n      types.definitionLabelMarker,\r\n      types.definitionLabelString\r\n    )(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function labelAfter(code) {\r\n    identifier = normalizeIdentifier(\r\n      self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\r\n    )\r\n\r\n    if (code === codes.colon) {\r\n      effects.enter(types.definitionMarker)\r\n      effects.consume(code)\r\n      effects.exit(types.definitionMarker)\r\n\r\n      // Note: blank lines can’t exist in content.\r\n      return factoryWhitespace(\r\n        effects,\r\n        factoryDestination(\r\n          effects,\r\n          effects.attempt(\r\n            titleConstruct,\r\n            factorySpace(effects, after, types.whitespace),\r\n            factorySpace(effects, after, types.whitespace)\r\n          ),\r\n          nok,\r\n          types.definitionDestination,\r\n          types.definitionDestinationLiteral,\r\n          types.definitionDestinationLiteralMarker,\r\n          types.definitionDestinationRaw,\r\n          types.definitionDestinationString\r\n        )\r\n      )\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function after(code) {\r\n    if (code === codes.eof || markdownLineEnding(code)) {\r\n      effects.exit(types.definition)\r\n\r\n      if (!self.parser.defined.includes(identifier)) {\r\n        self.parser.defined.push(identifier)\r\n      }\r\n\r\n      return ok(code)\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n}\r\n\r\n/** @type {Tokenizer} */\r\nfunction tokenizeTitle(effects, ok, nok) {\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    return markdownLineEndingOrSpace(code)\r\n      ? factoryWhitespace(effects, before)(code)\r\n      : nok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function before(code) {\r\n    if (\r\n      code === codes.quotationMark ||\r\n      code === codes.apostrophe ||\r\n      code === codes.leftParenthesis\r\n    ) {\r\n      return factoryTitle(\r\n        effects,\r\n        factorySpace(effects, after, types.whitespace),\r\n        nok,\r\n        types.definitionTitle,\r\n        types.definitionTitleMarker,\r\n        types.definitionTitleString\r\n      )(code)\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function after(code) {\r\n    return code === codes.eof || markdownLineEnding(code) ? ok(code) : nok(code)\r\n  }\r\n}\r\n", "/**\r\n * @typedef {import('micromark-util-types').Construct} Construct\r\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\r\n * @typedef {import('micromark-util-types').State} State\r\n */\r\n\r\nimport {ok as assert} from 'uvu/assert'\r\nimport {markdownLineEnding} from 'micromark-util-character'\r\nimport {codes} from 'micromark-util-symbol/codes.js'\r\nimport {types} from 'micromark-util-symbol/types.js'\r\n\r\n/** @type {Construct} */\r\nexport const hardBreakEscape = {\r\n  name: 'hardBreakEscape',\r\n  tokenize: tokenizeHardBreakEscape\r\n}\r\n\r\n/** @type {Tokenizer} */\r\nfunction tokenizeHardBreakEscape(effects, ok, nok) {\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    assert(code === codes.backslash, 'expected `\\\\`')\r\n    effects.enter(types.hardBreakEscape)\r\n    effects.enter(types.escapeMarker)\r\n    effects.consume(code)\r\n    return open\r\n  }\r\n\r\n  /** @type {State} */\r\n  function open(code) {\r\n    if (markdownLineEnding(code)) {\r\n      effects.exit(types.escapeMarker)\r\n      effects.exit(types.hardBreakEscape)\r\n      return ok(code)\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n}\r\n", "/**\r\n * @typedef {import('micromark-util-types').Construct} Construct\r\n * @typedef {import('micromark-util-types').Resolver} Resolver\r\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\r\n * @typedef {import('micromark-util-types').Token} Token\r\n * @typedef {import('micromark-util-types').State} State\r\n */\r\n\r\nimport {ok as assert} from 'uvu/assert'\r\nimport {factorySpace} from 'micromark-factory-space'\r\nimport {\r\n  markdownLineEnding,\r\n  markdownLineEndingOrSpace,\r\n  markdownSpace\r\n} from 'micromark-util-character'\r\nimport {splice} from 'micromark-util-chunked'\r\nimport {codes} from 'micromark-util-symbol/codes.js'\r\nimport {constants} from 'micromark-util-symbol/constants.js'\r\nimport {types} from 'micromark-util-symbol/types.js'\r\n\r\n/** @type {Construct} */\r\nexport const headingAtx = {\r\n  name: 'headingAtx',\r\n  tokenize: tokenizeHeadingAtx,\r\n  resolve: resolveHeadingAtx\r\n}\r\n\r\n/** @type {Resolver} */\r\nfunction resolveHeadingAtx(events, context) {\r\n  let contentEnd = events.length - 2\r\n  let contentStart = 3\r\n  /** @type {Token} */\r\n  let content\r\n  /** @type {Token} */\r\n  let text\r\n\r\n  // Prefix whitespace, part of the opening.\r\n  if (events[contentStart][1].type === types.whitespace) {\r\n    contentStart += 2\r\n  }\r\n\r\n  // Suffix whitespace, part of the closing.\r\n  if (\r\n    contentEnd - 2 > contentStart &&\r\n    events[contentEnd][1].type === types.whitespace\r\n  ) {\r\n    contentEnd -= 2\r\n  }\r\n\r\n  if (\r\n    events[contentEnd][1].type === types.atxHeadingSequence &&\r\n    (contentStart === contentEnd - 1 ||\r\n      (contentEnd - 4 > contentStart &&\r\n        events[contentEnd - 2][1].type === types.whitespace))\r\n  ) {\r\n    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4\r\n  }\r\n\r\n  if (contentEnd > contentStart) {\r\n    content = {\r\n      type: types.atxHeadingText,\r\n      start: events[contentStart][1].start,\r\n      end: events[contentEnd][1].end\r\n    }\r\n    text = {\r\n      type: types.chunkText,\r\n      start: events[contentStart][1].start,\r\n      end: events[contentEnd][1].end,\r\n      // @ts-expect-error Constants are fine to assign.\r\n      contentType: constants.contentTypeText\r\n    }\r\n\r\n    splice(events, contentStart, contentEnd - contentStart + 1, [\r\n      ['enter', content, context],\r\n      ['enter', text, context],\r\n      ['exit', text, context],\r\n      ['exit', content, context]\r\n    ])\r\n  }\r\n\r\n  return events\r\n}\r\n\r\n/** @type {Tokenizer} */\r\nfunction tokenizeHeadingAtx(effects, ok, nok) {\r\n  const self = this\r\n  let size = 0\r\n\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    assert(code === codes.numberSign, 'expected `#`')\r\n    effects.enter(types.atxHeading)\r\n    effects.enter(types.atxHeadingSequence)\r\n    return fenceOpenInside(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function fenceOpenInside(code) {\r\n    if (\r\n      code === codes.numberSign &&\r\n      size++ < constants.atxHeadingOpeningFenceSizeMax\r\n    ) {\r\n      effects.consume(code)\r\n      return fenceOpenInside\r\n    }\r\n\r\n    if (code === codes.eof || markdownLineEndingOrSpace(code)) {\r\n      effects.exit(types.atxHeadingSequence)\r\n      return self.interrupt ? ok(code) : headingBreak(code)\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function headingBreak(code) {\r\n    if (code === codes.numberSign) {\r\n      effects.enter(types.atxHeadingSequence)\r\n      return sequence(code)\r\n    }\r\n\r\n    if (code === codes.eof || markdownLineEnding(code)) {\r\n      effects.exit(types.atxHeading)\r\n      return ok(code)\r\n    }\r\n\r\n    if (markdownSpace(code)) {\r\n      return factorySpace(effects, headingBreak, types.whitespace)(code)\r\n    }\r\n\r\n    effects.enter(types.atxHeadingText)\r\n    return data(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function sequence(code) {\r\n    if (code === codes.numberSign) {\r\n      effects.consume(code)\r\n      return sequence\r\n    }\r\n\r\n    effects.exit(types.atxHeadingSequence)\r\n    return headingBreak(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function data(code) {\r\n    if (\r\n      code === codes.eof ||\r\n      code === codes.numberSign ||\r\n      markdownLineEndingOrSpace(code)\r\n    ) {\r\n      effects.exit(types.atxHeadingText)\r\n      return headingBreak(code)\r\n    }\r\n\r\n    effects.consume(code)\r\n    return data\r\n  }\r\n}\r\n", "/**\r\n * List of lowercase HTML tag names which when parsing HTML (flow), result\r\n * in more relaxed rules (condition 6): because they are known blocks, the\r\n * HTML-like syntax doesn’t have to be strictly parsed.\r\n * For tag names not in this list, a more strict algorithm (condition 7) is used\r\n * to detect whether the HTML-like syntax is seen as HTML (flow) or not.\r\n *\r\n * This is copied from:\r\n * <https://spec.commonmark.org/0.30/#html-blocks>.\r\n */\r\nexport const htmlBlockNames = [\r\n  'address',\r\n  'article',\r\n  'aside',\r\n  'base',\r\n  'basefont',\r\n  'blockquote',\r\n  'body',\r\n  'caption',\r\n  'center',\r\n  'col',\r\n  'colgroup',\r\n  'dd',\r\n  'details',\r\n  'dialog',\r\n  'dir',\r\n  'div',\r\n  'dl',\r\n  'dt',\r\n  'fieldset',\r\n  'figcaption',\r\n  'figure',\r\n  'footer',\r\n  'form',\r\n  'frame',\r\n  'frameset',\r\n  'h1',\r\n  'h2',\r\n  'h3',\r\n  'h4',\r\n  'h5',\r\n  'h6',\r\n  'head',\r\n  'header',\r\n  'hr',\r\n  'html',\r\n  'iframe',\r\n  'legend',\r\n  'li',\r\n  'link',\r\n  'main',\r\n  'menu',\r\n  'menuitem',\r\n  'nav',\r\n  'noframes',\r\n  'ol',\r\n  'optgroup',\r\n  'option',\r\n  'p',\r\n  'param',\r\n  'section',\r\n  'summary',\r\n  'table',\r\n  'tbody',\r\n  'td',\r\n  'tfoot',\r\n  'th',\r\n  'thead',\r\n  'title',\r\n  'tr',\r\n  'track',\r\n  'ul'\r\n]\r\n\r\n/**\r\n * List of lowercase HTML tag names which when parsing HTML (flow), result in\r\n * HTML that can include lines w/o exiting, until a closing tag also in this\r\n * list is found (condition 1).\r\n *\r\n * This module is copied from:\r\n * <https://spec.commonmark.org/0.30/#html-blocks>.\r\n *\r\n * Note that `textarea` was added in `CommonMark@0.30`.\r\n */\r\nexport const htmlRawNames = ['pre', 'script', 'style', 'textarea']\r\n", "/**\r\n * @typedef {import('micromark-util-types').Construct} Construct\r\n * @typedef {import('micromark-util-types').Resolver} Resolver\r\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\r\n * @typedef {import('micromark-util-types').State} State\r\n * @typedef {import('micromark-util-types').Code} Code\r\n */\r\n\r\nimport {ok as assert} from 'uvu/assert'\r\nimport {\r\n  asciiAlpha,\r\n  asciiAlphanumeric,\r\n  markdownLineEnding,\r\n  markdownLineEndingOrSpace,\r\n  markdownSpace\r\n} from 'micromark-util-character'\r\nimport {htmlBlockNames, htmlRawNames} from 'micromark-util-html-tag-name'\r\nimport {codes} from 'micromark-util-symbol/codes.js'\r\nimport {constants} from 'micromark-util-symbol/constants.js'\r\nimport {types} from 'micromark-util-symbol/types.js'\r\nimport {blankLine} from './blank-line.js'\r\n\r\n/** @type {Construct} */\r\nexport const htmlFlow = {\r\n  name: 'htmlFlow',\r\n  tokenize: tokenizeHtmlFlow,\r\n  resolveTo: resolveToHtmlFlow,\r\n  concrete: true\r\n}\r\n\r\n/** @type {Construct} */\r\nconst nextBlankConstruct = {tokenize: tokenizeNextBlank, partial: true}\r\n\r\n/** @type {Resolver} */\r\nfunction resolveToHtmlFlow(events) {\r\n  let index = events.length\r\n\r\n  while (index--) {\r\n    if (\r\n      events[index][0] === 'enter' &&\r\n      events[index][1].type === types.htmlFlow\r\n    ) {\r\n      break\r\n    }\r\n  }\r\n\r\n  if (index > 1 && events[index - 2][1].type === types.linePrefix) {\r\n    // Add the prefix start to the HTML token.\r\n    events[index][1].start = events[index - 2][1].start\r\n    // Add the prefix start to the HTML line token.\r\n    events[index + 1][1].start = events[index - 2][1].start\r\n    // Remove the line prefix.\r\n    events.splice(index - 2, 2)\r\n  }\r\n\r\n  return events\r\n}\r\n\r\n/** @type {Tokenizer} */\r\nfunction tokenizeHtmlFlow(effects, ok, nok) {\r\n  const self = this\r\n  /** @type {number} */\r\n  let kind\r\n  /** @type {boolean} */\r\n  let startTag\r\n  /** @type {string} */\r\n  let buffer\r\n  /** @type {number} */\r\n  let index\r\n  /** @type {Code} */\r\n  let marker\r\n\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    assert(code === codes.lessThan, 'expected `<`')\r\n    effects.enter(types.htmlFlow)\r\n    effects.enter(types.htmlFlowData)\r\n    effects.consume(code)\r\n    return open\r\n  }\r\n\r\n  /** @type {State} */\r\n  function open(code) {\r\n    if (code === codes.exclamationMark) {\r\n      effects.consume(code)\r\n      return declarationStart\r\n    }\r\n\r\n    if (code === codes.slash) {\r\n      effects.consume(code)\r\n      return tagCloseStart\r\n    }\r\n\r\n    if (code === codes.questionMark) {\r\n      effects.consume(code)\r\n      kind = constants.htmlInstruction\r\n      // While we’re in an instruction instead of a declaration, we’re on a `?`\r\n      // right now, so we do need to search for `>`, similar to declarations.\r\n      return self.interrupt ? ok : continuationDeclarationInside\r\n    }\r\n\r\n    if (asciiAlpha(code)) {\r\n      effects.consume(code)\r\n      buffer = String.fromCharCode(code)\r\n      startTag = true\r\n      return tagName\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function declarationStart(code) {\r\n    if (code === codes.dash) {\r\n      effects.consume(code)\r\n      kind = constants.htmlComment\r\n      return commentOpenInside\r\n    }\r\n\r\n    if (code === codes.leftSquareBracket) {\r\n      effects.consume(code)\r\n      kind = constants.htmlCdata\r\n      buffer = constants.cdataOpeningString\r\n      index = 0\r\n      return cdataOpenInside\r\n    }\r\n\r\n    if (asciiAlpha(code)) {\r\n      effects.consume(code)\r\n      kind = constants.htmlDeclaration\r\n      return self.interrupt ? ok : continuationDeclarationInside\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function commentOpenInside(code) {\r\n    if (code === codes.dash) {\r\n      effects.consume(code)\r\n      return self.interrupt ? ok : continuationDeclarationInside\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function cdataOpenInside(code) {\r\n    if (code === buffer.charCodeAt(index++)) {\r\n      effects.consume(code)\r\n      return index === buffer.length\r\n        ? self.interrupt\r\n          ? ok\r\n          : continuation\r\n        : cdataOpenInside\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function tagCloseStart(code) {\r\n    if (asciiAlpha(code)) {\r\n      effects.consume(code)\r\n      buffer = String.fromCharCode(code)\r\n      return tagName\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function tagName(code) {\r\n    if (\r\n      code === codes.eof ||\r\n      code === codes.slash ||\r\n      code === codes.greaterThan ||\r\n      markdownLineEndingOrSpace(code)\r\n    ) {\r\n      if (\r\n        code !== codes.slash &&\r\n        startTag &&\r\n        htmlRawNames.includes(buffer.toLowerCase())\r\n      ) {\r\n        kind = constants.htmlRaw\r\n        return self.interrupt ? ok(code) : continuation(code)\r\n      }\r\n\r\n      if (htmlBlockNames.includes(buffer.toLowerCase())) {\r\n        kind = constants.htmlBasic\r\n\r\n        if (code === codes.slash) {\r\n          effects.consume(code)\r\n          return basicSelfClosing\r\n        }\r\n\r\n        return self.interrupt ? ok(code) : continuation(code)\r\n      }\r\n\r\n      kind = constants.htmlComplete\r\n      // Do not support complete HTML when interrupting\r\n      return self.interrupt && !self.parser.lazy[self.now().line]\r\n        ? nok(code)\r\n        : startTag\r\n        ? completeAttributeNameBefore(code)\r\n        : completeClosingTagAfter(code)\r\n    }\r\n\r\n    if (code === codes.dash || asciiAlphanumeric(code)) {\r\n      effects.consume(code)\r\n      buffer += String.fromCharCode(code)\r\n      return tagName\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function basicSelfClosing(code) {\r\n    if (code === codes.greaterThan) {\r\n      effects.consume(code)\r\n      return self.interrupt ? ok : continuation\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function completeClosingTagAfter(code) {\r\n    if (markdownSpace(code)) {\r\n      effects.consume(code)\r\n      return completeClosingTagAfter\r\n    }\r\n\r\n    return completeEnd(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function completeAttributeNameBefore(code) {\r\n    if (code === codes.slash) {\r\n      effects.consume(code)\r\n      return completeEnd\r\n    }\r\n\r\n    if (code === codes.colon || code === codes.underscore || asciiAlpha(code)) {\r\n      effects.consume(code)\r\n      return completeAttributeName\r\n    }\r\n\r\n    if (markdownSpace(code)) {\r\n      effects.consume(code)\r\n      return completeAttributeNameBefore\r\n    }\r\n\r\n    return completeEnd(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function completeAttributeName(code) {\r\n    if (\r\n      code === codes.dash ||\r\n      code === codes.dot ||\r\n      code === codes.colon ||\r\n      code === codes.underscore ||\r\n      asciiAlphanumeric(code)\r\n    ) {\r\n      effects.consume(code)\r\n      return completeAttributeName\r\n    }\r\n\r\n    return completeAttributeNameAfter(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function completeAttributeNameAfter(code) {\r\n    if (code === codes.equalsTo) {\r\n      effects.consume(code)\r\n      return completeAttributeValueBefore\r\n    }\r\n\r\n    if (markdownSpace(code)) {\r\n      effects.consume(code)\r\n      return completeAttributeNameAfter\r\n    }\r\n\r\n    return completeAttributeNameBefore(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function completeAttributeValueBefore(code) {\r\n    if (\r\n      code === codes.eof ||\r\n      code === codes.lessThan ||\r\n      code === codes.equalsTo ||\r\n      code === codes.greaterThan ||\r\n      code === codes.graveAccent\r\n    ) {\r\n      return nok(code)\r\n    }\r\n\r\n    if (code === codes.quotationMark || code === codes.apostrophe) {\r\n      effects.consume(code)\r\n      marker = code\r\n      return completeAttributeValueQuoted\r\n    }\r\n\r\n    if (markdownSpace(code)) {\r\n      effects.consume(code)\r\n      return completeAttributeValueBefore\r\n    }\r\n\r\n    marker = null\r\n    return completeAttributeValueUnquoted(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function completeAttributeValueQuoted(code) {\r\n    if (code === codes.eof || markdownLineEnding(code)) {\r\n      return nok(code)\r\n    }\r\n\r\n    if (code === marker) {\r\n      effects.consume(code)\r\n      return completeAttributeValueQuotedAfter\r\n    }\r\n\r\n    effects.consume(code)\r\n    return completeAttributeValueQuoted\r\n  }\r\n\r\n  /** @type {State} */\r\n  function completeAttributeValueUnquoted(code) {\r\n    if (\r\n      code === codes.eof ||\r\n      code === codes.quotationMark ||\r\n      code === codes.apostrophe ||\r\n      code === codes.lessThan ||\r\n      code === codes.equalsTo ||\r\n      code === codes.greaterThan ||\r\n      code === codes.graveAccent ||\r\n      markdownLineEndingOrSpace(code)\r\n    ) {\r\n      return completeAttributeNameAfter(code)\r\n    }\r\n\r\n    effects.consume(code)\r\n    return completeAttributeValueUnquoted\r\n  }\r\n\r\n  /** @type {State} */\r\n  function completeAttributeValueQuotedAfter(code) {\r\n    if (\r\n      code === codes.slash ||\r\n      code === codes.greaterThan ||\r\n      markdownSpace(code)\r\n    ) {\r\n      return completeAttributeNameBefore(code)\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function completeEnd(code) {\r\n    if (code === codes.greaterThan) {\r\n      effects.consume(code)\r\n      return completeAfter\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function completeAfter(code) {\r\n    if (markdownSpace(code)) {\r\n      effects.consume(code)\r\n      return completeAfter\r\n    }\r\n\r\n    return code === codes.eof || markdownLineEnding(code)\r\n      ? continuation(code)\r\n      : nok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function continuation(code) {\r\n    if (code === codes.dash && kind === constants.htmlComment) {\r\n      effects.consume(code)\r\n      return continuationCommentInside\r\n    }\r\n\r\n    if (code === codes.lessThan && kind === constants.htmlRaw) {\r\n      effects.consume(code)\r\n      return continuationRawTagOpen\r\n    }\r\n\r\n    if (code === codes.greaterThan && kind === constants.htmlDeclaration) {\r\n      effects.consume(code)\r\n      return continuationClose\r\n    }\r\n\r\n    if (code === codes.questionMark && kind === constants.htmlInstruction) {\r\n      effects.consume(code)\r\n      return continuationDeclarationInside\r\n    }\r\n\r\n    if (code === codes.rightSquareBracket && kind === constants.htmlCdata) {\r\n      effects.consume(code)\r\n      return continuationCharacterDataInside\r\n    }\r\n\r\n    if (\r\n      markdownLineEnding(code) &&\r\n      (kind === constants.htmlBasic || kind === constants.htmlComplete)\r\n    ) {\r\n      return effects.check(\r\n        nextBlankConstruct,\r\n        continuationClose,\r\n        continuationAtLineEnding\r\n      )(code)\r\n    }\r\n\r\n    if (code === codes.eof || markdownLineEnding(code)) {\r\n      return continuationAtLineEnding(code)\r\n    }\r\n\r\n    effects.consume(code)\r\n    return continuation\r\n  }\r\n\r\n  /** @type {State} */\r\n  function continuationAtLineEnding(code) {\r\n    effects.exit(types.htmlFlowData)\r\n    return htmlContinueStart(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function htmlContinueStart(code) {\r\n    if (code === codes.eof) {\r\n      return done(code)\r\n    }\r\n\r\n    if (markdownLineEnding(code)) {\r\n      return effects.attempt(\r\n        {tokenize: htmlLineEnd, partial: true},\r\n        htmlContinueStart,\r\n        done\r\n      )(code)\r\n    }\r\n\r\n    effects.enter(types.htmlFlowData)\r\n    return continuation(code)\r\n  }\r\n\r\n  /** @type {Tokenizer} */\r\n  function htmlLineEnd(effects, ok, nok) {\r\n    return start\r\n\r\n    /** @type {State} */\r\n    function start(code) {\r\n      assert(markdownLineEnding(code), 'expected eol')\r\n      effects.enter(types.lineEnding)\r\n      effects.consume(code)\r\n      effects.exit(types.lineEnding)\r\n      return lineStart\r\n    }\r\n\r\n    /** @type {State} */\r\n    function lineStart(code) {\r\n      return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\r\n    }\r\n  }\r\n\r\n  /** @type {State} */\r\n  function continuationCommentInside(code) {\r\n    if (code === codes.dash) {\r\n      effects.consume(code)\r\n      return continuationDeclarationInside\r\n    }\r\n\r\n    return continuation(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function continuationRawTagOpen(code) {\r\n    if (code === codes.slash) {\r\n      effects.consume(code)\r\n      buffer = ''\r\n      return continuationRawEndTag\r\n    }\r\n\r\n    return continuation(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function continuationRawEndTag(code) {\r\n    if (\r\n      code === codes.greaterThan &&\r\n      htmlRawNames.includes(buffer.toLowerCase())\r\n    ) {\r\n      effects.consume(code)\r\n      return continuationClose\r\n    }\r\n\r\n    if (asciiAlpha(code) && buffer.length < constants.htmlRawSizeMax) {\r\n      effects.consume(code)\r\n      buffer += String.fromCharCode(code)\r\n      return continuationRawEndTag\r\n    }\r\n\r\n    return continuation(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function continuationCharacterDataInside(code) {\r\n    if (code === codes.rightSquareBracket) {\r\n      effects.consume(code)\r\n      return continuationDeclarationInside\r\n    }\r\n\r\n    return continuation(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function continuationDeclarationInside(code) {\r\n    if (code === codes.greaterThan) {\r\n      effects.consume(code)\r\n      return continuationClose\r\n    }\r\n\r\n    // More dashes.\r\n    if (code === codes.dash && kind === constants.htmlComment) {\r\n      effects.consume(code)\r\n      return continuationDeclarationInside\r\n    }\r\n\r\n    return continuation(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function continuationClose(code) {\r\n    if (code === codes.eof || markdownLineEnding(code)) {\r\n      effects.exit(types.htmlFlowData)\r\n      return done(code)\r\n    }\r\n\r\n    effects.consume(code)\r\n    return continuationClose\r\n  }\r\n\r\n  /** @type {State} */\r\n  function done(code) {\r\n    effects.exit(types.htmlFlow)\r\n    return ok(code)\r\n  }\r\n}\r\n\r\n/** @type {Tokenizer} */\r\nfunction tokenizeNextBlank(effects, ok, nok) {\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    assert(markdownLineEnding(code), 'expected a line ending')\r\n    effects.exit(types.htmlFlowData)\r\n    effects.enter(types.lineEndingBlank)\r\n    effects.consume(code)\r\n    effects.exit(types.lineEndingBlank)\r\n    return effects.attempt(blankLine, ok, nok)\r\n  }\r\n}\r\n", "/**\r\n * @typedef {import('micromark-util-types').Construct} Construct\r\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\r\n * @typedef {import('micromark-util-types').State} State\r\n * @typedef {import('micromark-util-types').Code} Code\r\n */\r\n\r\nimport {ok as assert} from 'uvu/assert'\r\nimport {factorySpace} from 'micromark-factory-space'\r\nimport {\r\n  asciiAlpha,\r\n  asciiAlphanumeric,\r\n  markdownLineEnding,\r\n  markdownLineEndingOrSpace,\r\n  markdownSpace\r\n} from 'micromark-util-character'\r\nimport {codes} from 'micromark-util-symbol/codes.js'\r\nimport {constants} from 'micromark-util-symbol/constants.js'\r\nimport {types} from 'micromark-util-symbol/types.js'\r\n\r\n/** @type {Construct} */\r\nexport const htmlText = {name: 'htmlText', tokenize: tokenizeHtmlText}\r\n\r\n/** @type {Tokenizer} */\r\nfunction tokenizeHtmlText(effects, ok, nok) {\r\n  const self = this\r\n  /** @type {NonNullable<Code>|undefined} */\r\n  let marker\r\n  /** @type {string} */\r\n  let buffer\r\n  /** @type {number} */\r\n  let index\r\n  /** @type {State} */\r\n  let returnState\r\n\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    assert(code === codes.lessThan, 'expected `<`')\r\n    effects.enter(types.htmlText)\r\n    effects.enter(types.htmlTextData)\r\n    effects.consume(code)\r\n    return open\r\n  }\r\n\r\n  /** @type {State} */\r\n  function open(code) {\r\n    if (code === codes.exclamationMark) {\r\n      effects.consume(code)\r\n      return declarationOpen\r\n    }\r\n\r\n    if (code === codes.slash) {\r\n      effects.consume(code)\r\n      return tagCloseStart\r\n    }\r\n\r\n    if (code === codes.questionMark) {\r\n      effects.consume(code)\r\n      return instruction\r\n    }\r\n\r\n    if (asciiAlpha(code)) {\r\n      effects.consume(code)\r\n      return tagOpen\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function declarationOpen(code) {\r\n    if (code === codes.dash) {\r\n      effects.consume(code)\r\n      return commentOpen\r\n    }\r\n\r\n    if (code === codes.leftSquareBracket) {\r\n      effects.consume(code)\r\n      buffer = constants.cdataOpeningString\r\n      index = 0\r\n      return cdataOpen\r\n    }\r\n\r\n    if (asciiAlpha(code)) {\r\n      effects.consume(code)\r\n      return declaration\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function commentOpen(code) {\r\n    if (code === codes.dash) {\r\n      effects.consume(code)\r\n      return commentStart\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function commentStart(code) {\r\n    if (code === codes.eof || code === codes.greaterThan) {\r\n      return nok(code)\r\n    }\r\n\r\n    if (code === codes.dash) {\r\n      effects.consume(code)\r\n      return commentStartDash\r\n    }\r\n\r\n    return comment(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function commentStartDash(code) {\r\n    if (code === codes.eof || code === codes.greaterThan) {\r\n      return nok(code)\r\n    }\r\n\r\n    return comment(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function comment(code) {\r\n    if (code === codes.eof) {\r\n      return nok(code)\r\n    }\r\n\r\n    if (code === codes.dash) {\r\n      effects.consume(code)\r\n      return commentClose\r\n    }\r\n\r\n    if (markdownLineEnding(code)) {\r\n      returnState = comment\r\n      return atLineEnding(code)\r\n    }\r\n\r\n    effects.consume(code)\r\n    return comment\r\n  }\r\n\r\n  /** @type {State} */\r\n  function commentClose(code) {\r\n    if (code === codes.dash) {\r\n      effects.consume(code)\r\n      return end\r\n    }\r\n\r\n    return comment(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function cdataOpen(code) {\r\n    if (code === buffer.charCodeAt(index++)) {\r\n      effects.consume(code)\r\n      return index === buffer.length ? cdata : cdataOpen\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function cdata(code) {\r\n    if (code === codes.eof) {\r\n      return nok(code)\r\n    }\r\n\r\n    if (code === codes.rightSquareBracket) {\r\n      effects.consume(code)\r\n      return cdataClose\r\n    }\r\n\r\n    if (markdownLineEnding(code)) {\r\n      returnState = cdata\r\n      return atLineEnding(code)\r\n    }\r\n\r\n    effects.consume(code)\r\n    return cdata\r\n  }\r\n\r\n  /** @type {State} */\r\n  function cdataClose(code) {\r\n    if (code === codes.rightSquareBracket) {\r\n      effects.consume(code)\r\n      return cdataEnd\r\n    }\r\n\r\n    return cdata(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function cdataEnd(code) {\r\n    if (code === codes.greaterThan) {\r\n      return end(code)\r\n    }\r\n\r\n    if (code === codes.rightSquareBracket) {\r\n      effects.consume(code)\r\n      return cdataEnd\r\n    }\r\n\r\n    return cdata(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function declaration(code) {\r\n    if (code === codes.eof || code === codes.greaterThan) {\r\n      return end(code)\r\n    }\r\n\r\n    if (markdownLineEnding(code)) {\r\n      returnState = declaration\r\n      return atLineEnding(code)\r\n    }\r\n\r\n    effects.consume(code)\r\n    return declaration\r\n  }\r\n\r\n  /** @type {State} */\r\n  function instruction(code) {\r\n    if (code === codes.eof) {\r\n      return nok(code)\r\n    }\r\n\r\n    if (code === codes.questionMark) {\r\n      effects.consume(code)\r\n      return instructionClose\r\n    }\r\n\r\n    if (markdownLineEnding(code)) {\r\n      returnState = instruction\r\n      return atLineEnding(code)\r\n    }\r\n\r\n    effects.consume(code)\r\n    return instruction\r\n  }\r\n\r\n  /** @type {State} */\r\n  function instructionClose(code) {\r\n    return code === codes.greaterThan ? end(code) : instruction(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function tagCloseStart(code) {\r\n    if (asciiAlpha(code)) {\r\n      effects.consume(code)\r\n      return tagClose\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function tagClose(code) {\r\n    if (code === codes.dash || asciiAlphanumeric(code)) {\r\n      effects.consume(code)\r\n      return tagClose\r\n    }\r\n\r\n    return tagCloseBetween(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function tagCloseBetween(code) {\r\n    if (markdownLineEnding(code)) {\r\n      returnState = tagCloseBetween\r\n      return atLineEnding(code)\r\n    }\r\n\r\n    if (markdownSpace(code)) {\r\n      effects.consume(code)\r\n      return tagCloseBetween\r\n    }\r\n\r\n    return end(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function tagOpen(code) {\r\n    if (code === codes.dash || asciiAlphanumeric(code)) {\r\n      effects.consume(code)\r\n      return tagOpen\r\n    }\r\n\r\n    if (\r\n      code === codes.slash ||\r\n      code === codes.greaterThan ||\r\n      markdownLineEndingOrSpace(code)\r\n    ) {\r\n      return tagOpenBetween(code)\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function tagOpenBetween(code) {\r\n    if (code === codes.slash) {\r\n      effects.consume(code)\r\n      return end\r\n    }\r\n\r\n    if (code === codes.colon || code === codes.underscore || asciiAlpha(code)) {\r\n      effects.consume(code)\r\n      return tagOpenAttributeName\r\n    }\r\n\r\n    if (markdownLineEnding(code)) {\r\n      returnState = tagOpenBetween\r\n      return atLineEnding(code)\r\n    }\r\n\r\n    if (markdownSpace(code)) {\r\n      effects.consume(code)\r\n      return tagOpenBetween\r\n    }\r\n\r\n    return end(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function tagOpenAttributeName(code) {\r\n    if (\r\n      code === codes.dash ||\r\n      code === codes.dot ||\r\n      code === codes.colon ||\r\n      code === codes.underscore ||\r\n      asciiAlphanumeric(code)\r\n    ) {\r\n      effects.consume(code)\r\n      return tagOpenAttributeName\r\n    }\r\n\r\n    return tagOpenAttributeNameAfter(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function tagOpenAttributeNameAfter(code) {\r\n    if (code === codes.equalsTo) {\r\n      effects.consume(code)\r\n      return tagOpenAttributeValueBefore\r\n    }\r\n\r\n    if (markdownLineEnding(code)) {\r\n      returnState = tagOpenAttributeNameAfter\r\n      return atLineEnding(code)\r\n    }\r\n\r\n    if (markdownSpace(code)) {\r\n      effects.consume(code)\r\n      return tagOpenAttributeNameAfter\r\n    }\r\n\r\n    return tagOpenBetween(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function tagOpenAttributeValueBefore(code) {\r\n    if (\r\n      code === codes.eof ||\r\n      code === codes.lessThan ||\r\n      code === codes.equalsTo ||\r\n      code === codes.greaterThan ||\r\n      code === codes.graveAccent\r\n    ) {\r\n      return nok(code)\r\n    }\r\n\r\n    if (code === codes.quotationMark || code === codes.apostrophe) {\r\n      effects.consume(code)\r\n      marker = code\r\n      return tagOpenAttributeValueQuoted\r\n    }\r\n\r\n    if (markdownLineEnding(code)) {\r\n      returnState = tagOpenAttributeValueBefore\r\n      return atLineEnding(code)\r\n    }\r\n\r\n    if (markdownSpace(code)) {\r\n      effects.consume(code)\r\n      return tagOpenAttributeValueBefore\r\n    }\r\n\r\n    effects.consume(code)\r\n    marker = undefined\r\n    return tagOpenAttributeValueUnquoted\r\n  }\r\n\r\n  /** @type {State} */\r\n  function tagOpenAttributeValueQuoted(code) {\r\n    if (code === marker) {\r\n      effects.consume(code)\r\n      return tagOpenAttributeValueQuotedAfter\r\n    }\r\n\r\n    if (code === codes.eof) {\r\n      return nok(code)\r\n    }\r\n\r\n    if (markdownLineEnding(code)) {\r\n      returnState = tagOpenAttributeValueQuoted\r\n      return atLineEnding(code)\r\n    }\r\n\r\n    effects.consume(code)\r\n    return tagOpenAttributeValueQuoted\r\n  }\r\n\r\n  /** @type {State} */\r\n  function tagOpenAttributeValueQuotedAfter(code) {\r\n    if (\r\n      code === codes.greaterThan ||\r\n      code === codes.slash ||\r\n      markdownLineEndingOrSpace(code)\r\n    ) {\r\n      return tagOpenBetween(code)\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function tagOpenAttributeValueUnquoted(code) {\r\n    if (\r\n      code === codes.eof ||\r\n      code === codes.quotationMark ||\r\n      code === codes.apostrophe ||\r\n      code === codes.lessThan ||\r\n      code === codes.equalsTo ||\r\n      code === codes.graveAccent\r\n    ) {\r\n      return nok(code)\r\n    }\r\n\r\n    if (code === codes.greaterThan || markdownLineEndingOrSpace(code)) {\r\n      return tagOpenBetween(code)\r\n    }\r\n\r\n    effects.consume(code)\r\n    return tagOpenAttributeValueUnquoted\r\n  }\r\n\r\n  // We can’t have blank lines in content, so no need to worry about empty\r\n  // tokens.\r\n  /** @type {State} */\r\n  function atLineEnding(code) {\r\n    assert(returnState, 'expected return state')\r\n    assert(markdownLineEnding(code), 'expected eol')\r\n    effects.exit(types.htmlTextData)\r\n    effects.enter(types.lineEnding)\r\n    effects.consume(code)\r\n    effects.exit(types.lineEnding)\r\n    return factorySpace(\r\n      effects,\r\n      afterPrefix,\r\n      types.linePrefix,\r\n      self.parser.constructs.disable.null.includes('codeIndented')\r\n        ? undefined\r\n        : constants.tabSize\r\n    )\r\n  }\r\n\r\n  /** @type {State} */\r\n  function afterPrefix(code) {\r\n    effects.enter(types.htmlTextData)\r\n    return returnState(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function end(code) {\r\n    if (code === codes.greaterThan) {\r\n      effects.consume(code)\r\n      effects.exit(types.htmlTextData)\r\n      effects.exit(types.htmlText)\r\n      return ok\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n}\r\n", "/**\r\n * @typedef {import('micromark-util-types').Construct} Construct\r\n * @typedef {import('micromark-util-types').Resolver} Resolver\r\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\r\n * @typedef {import('micromark-util-types').Event} Event\r\n * @typedef {import('micromark-util-types').Token} Token\r\n * @typedef {import('micromark-util-types').State} State\r\n * @typedef {import('micromark-util-types').Code} Code\r\n */\r\n\r\nimport {ok as assert} from 'uvu/assert'\r\nimport {factoryDestination} from 'micromark-factory-destination'\r\nimport {factoryLabel} from 'micromark-factory-label'\r\nimport {factoryTitle} from 'micromark-factory-title'\r\nimport {factoryWhitespace} from 'micromark-factory-whitespace'\r\nimport {markdownLineEndingOrSpace} from 'micromark-util-character'\r\nimport {push, splice} from 'micromark-util-chunked'\r\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\r\nimport {resolveAll} from 'micromark-util-resolve-all'\r\nimport {codes} from 'micromark-util-symbol/codes.js'\r\nimport {constants} from 'micromark-util-symbol/constants.js'\r\nimport {types} from 'micromark-util-symbol/types.js'\r\n\r\n/** @type {Construct} */\r\nexport const labelEnd = {\r\n  name: 'labelEnd',\r\n  tokenize: tokenizeLabelEnd,\r\n  resolveTo: resolveToLabelEnd,\r\n  resolveAll: resolveAllLabelEnd\r\n}\r\n\r\n/** @type {Construct} */\r\nconst resourceConstruct = {tokenize: tokenizeResource}\r\n/** @type {Construct} */\r\nconst fullReferenceConstruct = {tokenize: tokenizeFullReference}\r\n/** @type {Construct} */\r\nconst collapsedReferenceConstruct = {tokenize: tokenizeCollapsedReference}\r\n\r\n/** @type {Resolver} */\r\nfunction resolveAllLabelEnd(events) {\r\n  let index = -1\r\n  /** @type {Token} */\r\n  let token\r\n\r\n  while (++index < events.length) {\r\n    token = events[index][1]\r\n\r\n    if (\r\n      token.type === types.labelImage ||\r\n      token.type === types.labelLink ||\r\n      token.type === types.labelEnd\r\n    ) {\r\n      // Remove the marker.\r\n      events.splice(index + 1, token.type === types.labelImage ? 4 : 2)\r\n      token.type = types.data\r\n      index++\r\n    }\r\n  }\r\n\r\n  return events\r\n}\r\n\r\n/** @type {Resolver} */\r\nfunction resolveToLabelEnd(events, context) {\r\n  let index = events.length\r\n  let offset = 0\r\n  /** @type {Token} */\r\n  let token\r\n  /** @type {number|undefined} */\r\n  let open\r\n  /** @type {number|undefined} */\r\n  let close\r\n  /** @type {Event[]} */\r\n  let media\r\n\r\n  // Find an opening.\r\n  while (index--) {\r\n    token = events[index][1]\r\n\r\n    if (open) {\r\n      // If we see another link, or inactive link label, we’ve been here before.\r\n      if (\r\n        token.type === types.link ||\r\n        (token.type === types.labelLink && token._inactive)\r\n      ) {\r\n        break\r\n      }\r\n\r\n      // Mark other link openings as inactive, as we can’t have links in\r\n      // links.\r\n      if (events[index][0] === 'enter' && token.type === types.labelLink) {\r\n        token._inactive = true\r\n      }\r\n    } else if (close) {\r\n      if (\r\n        events[index][0] === 'enter' &&\r\n        (token.type === types.labelImage || token.type === types.labelLink) &&\r\n        !token._balanced\r\n      ) {\r\n        open = index\r\n\r\n        if (token.type !== types.labelLink) {\r\n          offset = 2\r\n          break\r\n        }\r\n      }\r\n    } else if (token.type === types.labelEnd) {\r\n      close = index\r\n    }\r\n  }\r\n\r\n  assert(open !== undefined, '`open` is supposed to be found')\r\n  assert(close !== undefined, '`close` is supposed to be found')\r\n\r\n  const group = {\r\n    type: events[open][1].type === types.labelLink ? types.link : types.image,\r\n    start: Object.assign({}, events[open][1].start),\r\n    end: Object.assign({}, events[events.length - 1][1].end)\r\n  }\r\n\r\n  const label = {\r\n    type: types.label,\r\n    start: Object.assign({}, events[open][1].start),\r\n    end: Object.assign({}, events[close][1].end)\r\n  }\r\n\r\n  const text = {\r\n    type: types.labelText,\r\n    start: Object.assign({}, events[open + offset + 2][1].end),\r\n    end: Object.assign({}, events[close - 2][1].start)\r\n  }\r\n\r\n  media = [\r\n    ['enter', group, context],\r\n    ['enter', label, context]\r\n  ]\r\n\r\n  // Opening marker.\r\n  media = push(media, events.slice(open + 1, open + offset + 3))\r\n\r\n  // Text open.\r\n  media = push(media, [['enter', text, context]])\r\n\r\n  // Between.\r\n  media = push(\r\n    media,\r\n    resolveAll(\r\n      context.parser.constructs.insideSpan.null,\r\n      events.slice(open + offset + 4, close - 3),\r\n      context\r\n    )\r\n  )\r\n\r\n  // Text close, marker close, label close.\r\n  media = push(media, [\r\n    ['exit', text, context],\r\n    events[close - 2],\r\n    events[close - 1],\r\n    ['exit', label, context]\r\n  ])\r\n\r\n  // Reference, resource, or so.\r\n  media = push(media, events.slice(close + 1))\r\n\r\n  // Media close.\r\n  media = push(media, [['exit', group, context]])\r\n\r\n  splice(events, open, events.length, media)\r\n\r\n  return events\r\n}\r\n\r\n/** @type {Tokenizer} */\r\nfunction tokenizeLabelEnd(effects, ok, nok) {\r\n  const self = this\r\n  let index = self.events.length\r\n  /** @type {Token} */\r\n  let labelStart\r\n  /** @type {boolean} */\r\n  let defined\r\n\r\n  // Find an opening.\r\n  while (index--) {\r\n    if (\r\n      (self.events[index][1].type === types.labelImage ||\r\n        self.events[index][1].type === types.labelLink) &&\r\n      !self.events[index][1]._balanced\r\n    ) {\r\n      labelStart = self.events[index][1]\r\n      break\r\n    }\r\n  }\r\n\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    assert(code === codes.rightSquareBracket, 'expected `]`')\r\n\r\n    if (!labelStart) {\r\n      return nok(code)\r\n    }\r\n\r\n    // It’s a balanced bracket, but contains a link.\r\n    if (labelStart._inactive) return balanced(code)\r\n    defined = self.parser.defined.includes(\r\n      normalizeIdentifier(\r\n        self.sliceSerialize({start: labelStart.end, end: self.now()})\r\n      )\r\n    )\r\n    effects.enter(types.labelEnd)\r\n    effects.enter(types.labelMarker)\r\n    effects.consume(code)\r\n    effects.exit(types.labelMarker)\r\n    effects.exit(types.labelEnd)\r\n    return afterLabelEnd\r\n  }\r\n\r\n  /** @type {State} */\r\n  function afterLabelEnd(code) {\r\n    // Resource: `[asd](fgh)`.\r\n    if (code === codes.leftParenthesis) {\r\n      return effects.attempt(\r\n        resourceConstruct,\r\n        ok,\r\n        defined ? ok : balanced\r\n      )(code)\r\n    }\r\n\r\n    // Collapsed (`[asd][]`) or full (`[asd][fgh]`) reference?\r\n    if (code === codes.leftSquareBracket) {\r\n      return effects.attempt(\r\n        fullReferenceConstruct,\r\n        ok,\r\n        defined\r\n          ? effects.attempt(collapsedReferenceConstruct, ok, balanced)\r\n          : balanced\r\n      )(code)\r\n    }\r\n\r\n    // Shortcut reference: `[asd]`?\r\n    return defined ? ok(code) : balanced(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function balanced(code) {\r\n    labelStart._balanced = true\r\n    return nok(code)\r\n  }\r\n}\r\n\r\n/** @type {Tokenizer} */\r\nfunction tokenizeResource(effects, ok, nok) {\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    assert(code === codes.leftParenthesis, 'expected left paren')\r\n    effects.enter(types.resource)\r\n    effects.enter(types.resourceMarker)\r\n    effects.consume(code)\r\n    effects.exit(types.resourceMarker)\r\n    return factoryWhitespace(effects, open)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function open(code) {\r\n    if (code === codes.rightParenthesis) {\r\n      return end(code)\r\n    }\r\n\r\n    return factoryDestination(\r\n      effects,\r\n      destinationAfter,\r\n      nok,\r\n      types.resourceDestination,\r\n      types.resourceDestinationLiteral,\r\n      types.resourceDestinationLiteralMarker,\r\n      types.resourceDestinationRaw,\r\n      types.resourceDestinationString,\r\n      constants.linkResourceDestinationBalanceMax\r\n    )(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function destinationAfter(code) {\r\n    return markdownLineEndingOrSpace(code)\r\n      ? factoryWhitespace(effects, between)(code)\r\n      : end(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function between(code) {\r\n    if (\r\n      code === codes.quotationMark ||\r\n      code === codes.apostrophe ||\r\n      code === codes.leftParenthesis\r\n    ) {\r\n      return factoryTitle(\r\n        effects,\r\n        factoryWhitespace(effects, end),\r\n        nok,\r\n        types.resourceTitle,\r\n        types.resourceTitleMarker,\r\n        types.resourceTitleString\r\n      )(code)\r\n    }\r\n\r\n    return end(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function end(code) {\r\n    if (code === codes.rightParenthesis) {\r\n      effects.enter(types.resourceMarker)\r\n      effects.consume(code)\r\n      effects.exit(types.resourceMarker)\r\n      effects.exit(types.resource)\r\n      return ok\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n}\r\n\r\n/** @type {Tokenizer} */\r\nfunction tokenizeFullReference(effects, ok, nok) {\r\n  const self = this\r\n\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    assert(code === codes.leftSquareBracket, 'expected left bracket')\r\n    return factoryLabel.call(\r\n      self,\r\n      effects,\r\n      afterLabel,\r\n      nok,\r\n      types.reference,\r\n      types.referenceMarker,\r\n      types.referenceString\r\n    )(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function afterLabel(code) {\r\n    return self.parser.defined.includes(\r\n      normalizeIdentifier(\r\n        self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\r\n      )\r\n    )\r\n      ? ok(code)\r\n      : nok(code)\r\n  }\r\n}\r\n\r\n/** @type {Tokenizer} */\r\nfunction tokenizeCollapsedReference(effects, ok, nok) {\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    assert(code === codes.leftSquareBracket, 'expected left bracket')\r\n    effects.enter(types.reference)\r\n    effects.enter(types.referenceMarker)\r\n    effects.consume(code)\r\n    effects.exit(types.referenceMarker)\r\n    return open\r\n  }\r\n\r\n  /** @type {State} */\r\n  function open(code) {\r\n    if (code === codes.rightSquareBracket) {\r\n      effects.enter(types.referenceMarker)\r\n      effects.consume(code)\r\n      effects.exit(types.referenceMarker)\r\n      effects.exit(types.reference)\r\n      return ok\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n}\r\n", "/**\r\n * @typedef {import('micromark-util-types').Construct} Construct\r\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\r\n * @typedef {import('micromark-util-types').State} State\r\n */\r\n\r\nimport {ok as assert} from 'uvu/assert'\r\nimport {codes} from 'micromark-util-symbol/codes.js'\r\nimport {types} from 'micromark-util-symbol/types.js'\r\nimport {labelEnd} from './label-end.js'\r\n\r\n/** @type {Construct} */\r\nexport const labelStartImage = {\r\n  name: 'labelStartImage',\r\n  tokenize: tokenizeLabelStartImage,\r\n  resolveAll: labelEnd.resolveAll\r\n}\r\n\r\n/** @type {Tokenizer} */\r\nfunction tokenizeLabelStartImage(effects, ok, nok) {\r\n  const self = this\r\n\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    assert(code === codes.exclamationMark, 'expected `!`')\r\n    effects.enter(types.labelImage)\r\n    effects.enter(types.labelImageMarker)\r\n    effects.consume(code)\r\n    effects.exit(types.labelImageMarker)\r\n    return open\r\n  }\r\n\r\n  /** @type {State} */\r\n  function open(code) {\r\n    if (code === codes.leftSquareBracket) {\r\n      effects.enter(types.labelMarker)\r\n      effects.consume(code)\r\n      effects.exit(types.labelMarker)\r\n      effects.exit(types.labelImage)\r\n      return after\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function after(code) {\r\n    /* To do: remove in the future once we’ve switched from\r\n     * `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,\r\n     * which doesn’t need this */\r\n    /* Hidden footnotes hook */\r\n    /* c8 ignore next 3 */\r\n    return code === codes.caret &&\r\n      '_hiddenFootnoteSupport' in self.parser.constructs\r\n      ? nok(code)\r\n      : ok(code)\r\n  }\r\n}\r\n", "/**\r\n * @typedef {import('micromark-util-types').Construct} Construct\r\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\r\n * @typedef {import('micromark-util-types').State} State\r\n */\r\n\r\nimport {ok as assert} from 'uvu/assert'\r\nimport {codes} from 'micromark-util-symbol/codes.js'\r\nimport {types} from 'micromark-util-symbol/types.js'\r\nimport {labelEnd} from './label-end.js'\r\n\r\n/** @type {Construct} */\r\nexport const labelStartLink = {\r\n  name: 'labelStartLink',\r\n  tokenize: tokenizeLabelStartLink,\r\n  resolveAll: labelEnd.resolveAll\r\n}\r\n\r\n/** @type {Tokenizer} */\r\nfunction tokenizeLabelStartLink(effects, ok, nok) {\r\n  const self = this\r\n\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    assert(code === codes.leftSquareBracket, 'expected `[`')\r\n    effects.enter(types.labelLink)\r\n    effects.enter(types.labelMarker)\r\n    effects.consume(code)\r\n    effects.exit(types.labelMarker)\r\n    effects.exit(types.labelLink)\r\n    return after\r\n  }\r\n\r\n  /** @type {State} */\r\n  function after(code) {\r\n    /* To do: remove in the future once we’ve switched from\r\n     * `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,\r\n     * which doesn’t need this */\r\n    /* Hidden footnotes hook. */\r\n    /* c8 ignore next 3 */\r\n    return code === codes.caret &&\r\n      '_hiddenFootnoteSupport' in self.parser.constructs\r\n      ? nok(code)\r\n      : ok(code)\r\n  }\r\n}\r\n", "/**\r\n * @typedef {import('micromark-util-types').Construct} Construct\r\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\r\n * @typedef {import('micromark-util-types').State} State\r\n */\r\n\r\nimport {ok as assert} from 'uvu/assert'\r\nimport {factorySpace} from 'micromark-factory-space'\r\nimport {markdownLineEnding} from 'micromark-util-character'\r\nimport {types} from 'micromark-util-symbol/types.js'\r\n\r\n/** @type {Construct} */\r\nexport const lineEnding = {name: 'lineEnding', tokenize: tokenizeLineEnding}\r\n\r\n/** @type {Tokenizer} */\r\nfunction tokenizeLineEnding(effects, ok) {\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    assert(markdownLineEnding(code), 'expected eol')\r\n    effects.enter(types.lineEnding)\r\n    effects.consume(code)\r\n    effects.exit(types.lineEnding)\r\n    return factorySpace(effects, ok, types.linePrefix)\r\n  }\r\n}\r\n", "/**\r\n * @typedef {import('micromark-util-types').Construct} Construct\r\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\r\n * @typedef {import('micromark-util-types').State} State\r\n * @typedef {import('micromark-util-types').Code} Code\r\n */\r\n\r\nimport {ok as assert} from 'uvu/assert'\r\nimport {factorySpace} from 'micromark-factory-space'\r\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\r\nimport {codes} from 'micromark-util-symbol/codes.js'\r\nimport {constants} from 'micromark-util-symbol/constants.js'\r\nimport {types} from 'micromark-util-symbol/types.js'\r\n\r\n/** @type {Construct} */\r\nexport const thematicBreak = {\r\n  name: 'thematicBreak',\r\n  tokenize: tokenizeThematicBreak\r\n}\r\n\r\n/** @type {Tokenizer} */\r\nfunction tokenizeThematicBreak(effects, ok, nok) {\r\n  let size = 0\r\n  /** @type {NonNullable<Code>} */\r\n  let marker\r\n\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    assert(\r\n      code === codes.asterisk ||\r\n        code === codes.dash ||\r\n        code === codes.underscore,\r\n      'expected `*`, `-`, or `_`'\r\n    )\r\n\r\n    effects.enter(types.thematicBreak)\r\n    marker = code\r\n    return atBreak(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function atBreak(code) {\r\n    if (code === marker) {\r\n      effects.enter(types.thematicBreakSequence)\r\n      return sequence(code)\r\n    }\r\n\r\n    if (markdownSpace(code)) {\r\n      return factorySpace(effects, atBreak, types.whitespace)(code)\r\n    }\r\n\r\n    if (\r\n      size < constants.thematicBreakMarkerCountMin ||\r\n      (code !== codes.eof && !markdownLineEnding(code))\r\n    ) {\r\n      return nok(code)\r\n    }\r\n\r\n    effects.exit(types.thematicBreak)\r\n    return ok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function sequence(code) {\r\n    if (code === marker) {\r\n      effects.consume(code)\r\n      size++\r\n      return sequence\r\n    }\r\n\r\n    effects.exit(types.thematicBreakSequence)\r\n    return atBreak(code)\r\n  }\r\n}\r\n", "/**\r\n * @typedef {import('micromark-util-types').Construct} Construct\r\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\r\n * @typedef {import('micromark-util-types').Exiter} Exiter\r\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\r\n * @typedef {import('micromark-util-types').State} State\r\n * @typedef {import('micromark-util-types').Code} Code\r\n */\r\n\r\n/**\r\n * @typedef {Record<string, unknown> & {marker: Code, type: string, size: number}} ListContainerState\r\n * @typedef {TokenizeContext & {containerState: ListContainerState}} TokenizeContextWithState\r\n */\r\n\r\nimport {ok as assert} from 'uvu/assert'\r\nimport {factorySpace} from 'micromark-factory-space'\r\nimport {asciiDigit, markdownSpace} from 'micromark-util-character'\r\nimport {codes} from 'micromark-util-symbol/codes.js'\r\nimport {constants} from 'micromark-util-symbol/constants.js'\r\nimport {types} from 'micromark-util-symbol/types.js'\r\nimport {blankLine} from './blank-line.js'\r\nimport {thematicBreak} from './thematic-break.js'\r\n\r\n/** @type {Construct} */\r\nexport const list = {\r\n  name: 'list',\r\n  tokenize: tokenizeListStart,\r\n  continuation: {tokenize: tokenizeListContinuation},\r\n  exit: tokenizeListEnd\r\n}\r\n\r\n/** @type {Construct} */\r\nconst listItemPrefixWhitespaceConstruct = {\r\n  tokenize: tokenizeListItemPrefixWhitespace,\r\n  partial: true\r\n}\r\n\r\n/** @type {Construct} */\r\nconst indentConstruct = {tokenize: tokenizeIndent, partial: true}\r\n\r\n/**\r\n * @type {Tokenizer}\r\n * @this {TokenizeContextWithState}\r\n */\r\nfunction tokenizeListStart(effects, ok, nok) {\r\n  const self = this\r\n  const tail = self.events[self.events.length - 1]\r\n  let initialSize =\r\n    tail && tail[1].type === types.linePrefix\r\n      ? tail[2].sliceSerialize(tail[1], true).length\r\n      : 0\r\n  let size = 0\r\n\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    const kind =\r\n      self.containerState.type ||\r\n      (code === codes.asterisk || code === codes.plusSign || code === codes.dash\r\n        ? types.listUnordered\r\n        : types.listOrdered)\r\n\r\n    if (\r\n      kind === types.listUnordered\r\n        ? !self.containerState.marker || code === self.containerState.marker\r\n        : asciiDigit(code)\r\n    ) {\r\n      if (!self.containerState.type) {\r\n        self.containerState.type = kind\r\n        effects.enter(kind, {_container: true})\r\n      }\r\n\r\n      if (kind === types.listUnordered) {\r\n        effects.enter(types.listItemPrefix)\r\n        return code === codes.asterisk || code === codes.dash\r\n          ? effects.check(thematicBreak, nok, atMarker)(code)\r\n          : atMarker(code)\r\n      }\r\n\r\n      if (!self.interrupt || code === codes.digit1) {\r\n        effects.enter(types.listItemPrefix)\r\n        effects.enter(types.listItemValue)\r\n        return inside(code)\r\n      }\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function inside(code) {\r\n    if (asciiDigit(code) && ++size < constants.listItemValueSizeMax) {\r\n      effects.consume(code)\r\n      return inside\r\n    }\r\n\r\n    if (\r\n      (!self.interrupt || size < 2) &&\r\n      (self.containerState.marker\r\n        ? code === self.containerState.marker\r\n        : code === codes.rightParenthesis || code === codes.dot)\r\n    ) {\r\n      effects.exit(types.listItemValue)\r\n      return atMarker(code)\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /**\r\n   * @type {State}\r\n   **/\r\n  function atMarker(code) {\r\n    assert(code !== codes.eof, 'eof (`null`) is not a marker')\r\n    effects.enter(types.listItemMarker)\r\n    effects.consume(code)\r\n    effects.exit(types.listItemMarker)\r\n    self.containerState.marker = self.containerState.marker || code\r\n    return effects.check(\r\n      blankLine,\r\n      // Can’t be empty when interrupting.\r\n      self.interrupt ? nok : onBlank,\r\n      effects.attempt(\r\n        listItemPrefixWhitespaceConstruct,\r\n        endOfPrefix,\r\n        otherPrefix\r\n      )\r\n    )\r\n  }\r\n\r\n  /** @type {State} */\r\n  function onBlank(code) {\r\n    self.containerState.initialBlankLine = true\r\n    initialSize++\r\n    return endOfPrefix(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function otherPrefix(code) {\r\n    if (markdownSpace(code)) {\r\n      effects.enter(types.listItemPrefixWhitespace)\r\n      effects.consume(code)\r\n      effects.exit(types.listItemPrefixWhitespace)\r\n      return endOfPrefix\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function endOfPrefix(code) {\r\n    self.containerState.size =\r\n      initialSize +\r\n      self.sliceSerialize(effects.exit(types.listItemPrefix), true).length\r\n    return ok(code)\r\n  }\r\n}\r\n\r\n/**\r\n * @type {Tokenizer}\r\n * @this {TokenizeContextWithState}\r\n */\r\nfunction tokenizeListContinuation(effects, ok, nok) {\r\n  const self = this\r\n\r\n  self.containerState._closeFlow = undefined\r\n\r\n  return effects.check(blankLine, onBlank, notBlank)\r\n\r\n  /** @type {State} */\r\n  function onBlank(code) {\r\n    self.containerState.furtherBlankLines =\r\n      self.containerState.furtherBlankLines ||\r\n      self.containerState.initialBlankLine\r\n\r\n    // We have a blank line.\r\n    // Still, try to consume at most the items size.\r\n    return factorySpace(\r\n      effects,\r\n      ok,\r\n      types.listItemIndent,\r\n      self.containerState.size + 1\r\n    )(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function notBlank(code) {\r\n    if (self.containerState.furtherBlankLines || !markdownSpace(code)) {\r\n      self.containerState.furtherBlankLines = undefined\r\n      self.containerState.initialBlankLine = undefined\r\n      return notInCurrentItem(code)\r\n    }\r\n\r\n    self.containerState.furtherBlankLines = undefined\r\n    self.containerState.initialBlankLine = undefined\r\n    return effects.attempt(indentConstruct, ok, notInCurrentItem)(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function notInCurrentItem(code) {\r\n    // While we do continue, we signal that the flow should be closed.\r\n    self.containerState._closeFlow = true\r\n    // As we’re closing flow, we’re no longer interrupting.\r\n    self.interrupt = undefined\r\n    return factorySpace(\r\n      effects,\r\n      effects.attempt(list, ok, nok),\r\n      types.linePrefix,\r\n      self.parser.constructs.disable.null.includes('codeIndented')\r\n        ? undefined\r\n        : constants.tabSize\r\n    )(code)\r\n  }\r\n}\r\n\r\n/**\r\n * @type {Tokenizer}\r\n * @this {TokenizeContextWithState}\r\n */\r\nfunction tokenizeIndent(effects, ok, nok) {\r\n  const self = this\r\n\r\n  return factorySpace(\r\n    effects,\r\n    afterPrefix,\r\n    types.listItemIndent,\r\n    self.containerState.size + 1\r\n  )\r\n\r\n  /** @type {State} */\r\n  function afterPrefix(code) {\r\n    const tail = self.events[self.events.length - 1]\r\n    return tail &&\r\n      tail[1].type === types.listItemIndent &&\r\n      tail[2].sliceSerialize(tail[1], true).length === self.containerState.size\r\n      ? ok(code)\r\n      : nok(code)\r\n  }\r\n}\r\n\r\n/**\r\n * @type {Exiter}\r\n * @this {TokenizeContextWithState}\r\n */\r\nfunction tokenizeListEnd(effects) {\r\n  effects.exit(this.containerState.type)\r\n}\r\n\r\n/**\r\n * @type {Tokenizer}\r\n * @this {TokenizeContextWithState}\r\n */\r\nfunction tokenizeListItemPrefixWhitespace(effects, ok, nok) {\r\n  const self = this\r\n\r\n  return factorySpace(\r\n    effects,\r\n    afterPrefix,\r\n    types.listItemPrefixWhitespace,\r\n    self.parser.constructs.disable.null.includes('codeIndented')\r\n      ? undefined\r\n      : constants.tabSize + 1\r\n  )\r\n\r\n  /** @type {State} */\r\n  function afterPrefix(code) {\r\n    const tail = self.events[self.events.length - 1]\r\n\r\n    return !markdownSpace(code) &&\r\n      tail &&\r\n      tail[1].type === types.listItemPrefixWhitespace\r\n      ? ok(code)\r\n      : nok(code)\r\n  }\r\n}\r\n", "/**\r\n * @typedef {import('micromark-util-types').Construct} Construct\r\n * @typedef {import('micromark-util-types').Resolver} Resolver\r\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\r\n * @typedef {import('micromark-util-types').State} State\r\n * @typedef {import('micromark-util-types').Code} Code\r\n */\r\n\r\nimport {ok as assert} from 'uvu/assert'\r\nimport {factorySpace} from 'micromark-factory-space'\r\nimport {markdownLineEnding} from 'micromark-util-character'\r\nimport {codes} from 'micromark-util-symbol/codes.js'\r\nimport {types} from 'micromark-util-symbol/types.js'\r\n\r\n/** @type {Construct} */\r\nexport const setextUnderline = {\r\n  name: 'setextUnderline',\r\n  tokenize: tokenizeSetextUnderline,\r\n  resolveTo: resolveToSetextUnderline\r\n}\r\n\r\n/** @type {Resolver} */\r\nfunction resolveToSetextUnderline(events, context) {\r\n  let index = events.length\r\n  /** @type {number|undefined} */\r\n  let content\r\n  /** @type {number|undefined} */\r\n  let text\r\n  /** @type {number|undefined} */\r\n  let definition\r\n\r\n  // Find the opening of the content.\r\n  // It’ll always exist: we don’t tokenize if it isn’t there.\r\n  while (index--) {\r\n    if (events[index][0] === 'enter') {\r\n      if (events[index][1].type === types.content) {\r\n        content = index\r\n        break\r\n      }\r\n\r\n      if (events[index][1].type === types.paragraph) {\r\n        text = index\r\n      }\r\n    }\r\n    // Exit\r\n    else {\r\n      if (events[index][1].type === types.content) {\r\n        // Remove the content end (if needed we’ll add it later)\r\n        events.splice(index, 1)\r\n      }\r\n\r\n      if (!definition && events[index][1].type === types.definition) {\r\n        definition = index\r\n      }\r\n    }\r\n  }\r\n\r\n  assert(text !== undefined, 'expected a `text` index to be found')\r\n  assert(content !== undefined, 'expected a `text` index to be found')\r\n\r\n  const heading = {\r\n    type: types.setextHeading,\r\n    start: Object.assign({}, events[text][1].start),\r\n    end: Object.assign({}, events[events.length - 1][1].end)\r\n  }\r\n\r\n  // Change the paragraph to setext heading text.\r\n  events[text][1].type = types.setextHeadingText\r\n\r\n  // If we have definitions in the content, we’ll keep on having content,\r\n  // but we need move it.\r\n  if (definition) {\r\n    events.splice(text, 0, ['enter', heading, context])\r\n    events.splice(definition + 1, 0, ['exit', events[content][1], context])\r\n    events[content][1].end = Object.assign({}, events[definition][1].end)\r\n  } else {\r\n    events[content][1] = heading\r\n  }\r\n\r\n  // Add the heading exit at the end.\r\n  events.push(['exit', heading, context])\r\n\r\n  return events\r\n}\r\n\r\n/** @type {Tokenizer} */\r\nfunction tokenizeSetextUnderline(effects, ok, nok) {\r\n  const self = this\r\n  let index = self.events.length\r\n  /** @type {NonNullable<Code>} */\r\n  let marker\r\n  /** @type {boolean} */\r\n  let paragraph\r\n\r\n  // Find an opening.\r\n  while (index--) {\r\n    // Skip enter/exit of line ending, line prefix, and content.\r\n    // We can now either have a definition or a paragraph.\r\n    if (\r\n      self.events[index][1].type !== types.lineEnding &&\r\n      self.events[index][1].type !== types.linePrefix &&\r\n      self.events[index][1].type !== types.content\r\n    ) {\r\n      paragraph = self.events[index][1].type === types.paragraph\r\n      break\r\n    }\r\n  }\r\n\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    assert(\r\n      code === codes.dash || code === codes.equalsTo,\r\n      'expected `=` or `-`'\r\n    )\r\n\r\n    if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph)) {\r\n      effects.enter(types.setextHeadingLine)\r\n      effects.enter(types.setextHeadingLineSequence)\r\n      marker = code\r\n      return closingSequence(code)\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function closingSequence(code) {\r\n    if (code === marker) {\r\n      effects.consume(code)\r\n      return closingSequence\r\n    }\r\n\r\n    effects.exit(types.setextHeadingLineSequence)\r\n    return factorySpace(effects, closingSequenceEnd, types.lineSuffix)(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function closingSequenceEnd(code) {\r\n    if (code === codes.eof || markdownLineEnding(code)) {\r\n      effects.exit(types.setextHeadingLine)\r\n      return ok(code)\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n}\r\n", "import {codes} from 'micromark-util-symbol/codes.js'\r\nimport {values} from 'micromark-util-symbol/values.js'\r\n\r\n/**\r\n * Turn the number (in string form as either hexa- or plain decimal) coming from\r\n * a numeric character reference into a character.\r\n *\r\n * @param {string} value\r\n *   Value to decode.\r\n * @param {number} base\r\n *   Numeric base.\r\n * @returns {string}\r\n */\r\nexport function decodeNumericCharacterReference(value, base) {\r\n  const code = Number.parseInt(value, base)\r\n\r\n  if (\r\n    // C0 except for HT, LF, FF, CR, space\r\n    code < codes.ht ||\r\n    code === codes.vt ||\r\n    (code > codes.cr && code < codes.space) ||\r\n    // Control character (DEL) of the basic block and C1 controls.\r\n    (code > codes.tilde && code < 160) ||\r\n    // Lone high surrogates and low surrogates.\r\n    (code > 55295 && code < 57344) ||\r\n    // Noncharacters.\r\n    (code > 64975 && code < 65008) ||\r\n    (code & 65535) === 65535 ||\r\n    (code & 65535) === 65534 ||\r\n    // Out of range\r\n    code > 1114111\r\n  ) {\r\n    return values.replacementCharacter\r\n  }\r\n\r\n  return String.fromCharCode(code)\r\n}\r\n", "import {decodeNamedCharacterReference} from 'decode-named-character-reference'\r\nimport {decodeNumericCharacterReference} from 'micromark-util-decode-numeric-character-reference'\r\nimport {codes} from 'micromark-util-symbol/codes.js'\r\nimport {constants} from 'micromark-util-symbol/constants.js'\r\n\r\nconst characterEscapeOrReference =\r\n  /\\\\([!-/:-@[-`{-~])|&(#(?:\\d{1,7}|x[\\da-f]{1,6})|[\\da-z]{1,31});/gi\r\n\r\n/**\r\n * Utility to decode markdown strings (which occur in places such as fenced\r\n * code info strings, destinations, labels, and titles).\r\n * The “string” content type allows character escapes and -references.\r\n * This decodes those.\r\n *\r\n * @param {string} value\r\n * @returns {string}\r\n */\r\nexport function decodeString(value) {\r\n  return value.replace(characterEscapeOrReference, decode)\r\n}\r\n\r\n/**\r\n * @param {string} $0\r\n * @param {string} $1\r\n * @param {string} $2\r\n * @returns {string}\r\n */\r\nfunction decode($0, $1, $2) {\r\n  if ($1) {\r\n    // Escape.\r\n    return $1\r\n  }\r\n\r\n  // Reference.\r\n  const head = $2.charCodeAt(0)\r\n\r\n  if (head === codes.numberSign) {\r\n    const head = $2.charCodeAt(1)\r\n    const hex = head === codes.lowercaseX || head === codes.uppercaseX\r\n    return decodeNumericCharacterReference(\r\n      $2.slice(hex ? 2 : 1),\r\n      hex ? constants.numericBaseHexadecimal : constants.numericBaseDecimal\r\n    )\r\n  }\r\n\r\n  return decodeNamedCharacterReference($2) || $0\r\n}\r\n"],
  "mappings": "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",
  "names": ["list", "list", "has", "chars", "diff", "value", "line", "obj", "ok", "constructs", "ok", "ok", "previous", "ok", "ok", "ok", "characterReference", "ok", "ok", "effects", "nok", "self", "start", "ok", "content", "ok", "previous", "start", "ok", "previous", "ok", "ok", "ok", "ok", "ok", "ok", "content", "ok", "ok", "effects", "nok", "start", "ok", "ok", "ok", "ok", "ok", "ok", "ok", "content", "definition", "ok", "head"]
}
